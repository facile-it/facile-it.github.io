<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DSL on Facile.it Engineering</title>
    <link>https://engineering.facile.it/categories/dsl/</link>
    <description>Recent content in DSL on Facile.it Engineering</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 08 Feb 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://engineering.facile.it/categories/dsl/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Using Kotlin type-safe builders to create a DSL for Forms</title>
      <link>https://engineering.facile.it/blog/eng/kotlin-dsl/</link>
      <pubDate>Wed, 08 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://engineering.facile.it/blog/eng/kotlin-dsl/</guid>
      <description>

&lt;p&gt;Here at Facile.it we are constantly dealing with a lot of &lt;strong&gt;forms&lt;/strong&gt;: we use them to collect various information and data needed to feed our in-house comparing algorithms. These forms could be &lt;strong&gt;really complex&lt;/strong&gt;, having multiple rules and dependencies between fields, and they are likely to be &lt;strong&gt;changed and tuned frequently&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;When I joined Facile.it, a lot of forms within the Android app needed to be updated or modified and sticking with the existing strategy would have required me to do &lt;strong&gt;a lot of work&lt;/strong&gt; just to add or remove a simple field. So I took a step back and I started thinking about a strategy that would have allowed me to define and structure a form in a more &lt;em&gt;flexible&lt;/em&gt; and &lt;em&gt;declarative&lt;/em&gt; way. I wanted to be able to declare the &lt;strong&gt;relationships&lt;/strong&gt; between fields, their &lt;strong&gt;validation rules&lt;/strong&gt; and their &lt;strong&gt;serialized representation&lt;/strong&gt; (how they are sent to the server).&lt;/p&gt;

&lt;p&gt;I firstly thought about defining it using some configuration file, maybe written in JSON or YAML. The &lt;em&gt;problem&lt;/em&gt; with this strategy was that it would also have required me to write a lot code to parse and validate those files to be able to create some sort of representation of the form in Java&amp;hellip;but don&amp;rsquo;t we already have the compiler for this kind of jobs?&lt;/p&gt;

&lt;p&gt;I still wanted to be able to have both a &lt;strong&gt;human readable representation&lt;/strong&gt; of the form and the right degree of &lt;strong&gt;flexibility&lt;/strong&gt; to integrate the form definition into the app code.
So I thought that creating a &lt;a href=&#34;https://en.wikipedia.org/wiki/Domain-specific_language&#34;&gt;Domain-Specific Language&lt;/a&gt; would have been a perfect strategy to solve the problem in an elegant and efficient way.
Writing a DSL in Java could have ended up into something like that:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Form.create()
    .openSection(sectionId)
    .field(key1, &amp;quot;label1&amp;quot;, style, ...) 
    .field(key2, &amp;quot;label2&amp;quot;, style, ...) 
    .field(key3, &amp;quot;label3&amp;quot;, style, ...) 
    .closeSection()
    ...
    .build()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I don&amp;rsquo;t think the previous code is readable nor flexible and it requires a lot of boilerplate to be written.&lt;/p&gt;

&lt;h2 id=&#34;kotlin-to-the-rescue&#34;&gt;Kotlin to the rescue!&lt;/h2&gt;

&lt;p&gt;Unlike Java, Kotlin (take a look at my &lt;a href=&#34;https://engineering.facile.it/blog/eng/kotlin-intro/&#34;&gt;previous post&lt;/a&gt; about it) has a lot of features that makes it really powerful when it comes to write internal DSLs. The results are very similar to Groovy (think about a Gradle file) but thanks to its type system they could be &lt;a href=&#34;https://kotlinlang.org/docs/reference/type-safe-builders.html#type-safe-builders&#34;&gt;Type-Safe&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The builders you can write with Kotlin are extremely readable and easy to understand even for people that don&amp;rsquo;t know either the language or the DSL itself. Here&amp;rsquo;s how a form built using my final DSL looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val FORM = form {
    page(&amp;quot;Page 1 Title&amp;quot;) {
        section(&amp;quot;Section 1 Title&amp;quot;) {
            field(key = &amp;quot;fieldKey1&amp;quot;) {
                checkbox(&amp;quot;Checkbox Field Label&amp;quot;) {
                    boolToStringConverter = { if (it == true) &amp;quot;Yes&amp;quot; else &amp;quot;No&amp;quot; }
                    rules = { listOf(NotMissing()) }
                }
            }
            field(key = &amp;quot;fieldKey2&amp;quot;) {
                picker(&amp;quot;Picker Field Label&amp;quot;) {
                    placeHolder = &amp;quot;Select a value&amp;quot;
                    possibleValues = Available(listOf(
                            1 keyTo &amp;quot;Value1&amp;quot;,
                            2 keyTo &amp;quot;Value2&amp;quot;,
                            3 keyTo &amp;quot;Value3&amp;quot;))
                    representation = IF_VISIBLE representAs SIMPLE_KEY_TO_VALUE
                }
            }
        }
        section(&amp;quot;Section 2 Title&amp;quot;) {
            field(key = &amp;quot;fieldKey3&amp;quot;) {
                picker(&amp;quot;Picker Field Label&amp;quot;) {
                    placeHolder = &amp;quot;Select a value&amp;quot;
                    possibleValues = ToBeRetrieved(someWebService.getValues())
                    representation = IF_VISIBLE representAs SIMPLE_KEY_TO_VALUE
                }
            }
            field(key = &amp;quot;fieldKey4&amp;quot;) {
                input(&amp;quot;Input Text Field Label&amp;quot;) {
                    inputTextType = InputTextType.EMAIL
                    rules = { listOf(IsEmail()) }
                }
            }
            field(key = &amp;quot;fieldKey&amp;quot;) {
				        empty(&amp;quot;Empty Field&amp;quot;)
            }
        }
		    section(&amp;quot;Section 3 Title&amp;quot;) {
            field(key = &amp;quot;fieldKey6&amp;quot;) {
                toggle(&amp;quot;Toggle Field Label&amp;quot;) {
                    boolToStringConverter = { if (it == true) &amp;quot;OK&amp;quot; else &amp;quot;KO&amp;quot; }
                    rules = { listOf(NotMissing()) }
                    representation = ALWAYS representAs SIMPLE_KEY_TO_VALUE
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And this is the result on Android using my &lt;a href=&#34;https://github.com/brescia123/forms&#34;&gt;Form library&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://engineering.facile.it/images/kotlin-dsl/form_screen.png&#34; alt=&#34;Form screenshot&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Cool, isn&amp;rsquo;t it?&lt;/p&gt;

&lt;h2 id=&#34;type-safe-builders&#34;&gt;Type-safe builders&lt;/h2&gt;

&lt;h3 id=&#34;some-kotlin-important-features&#34;&gt;Some Kotlin important features&lt;/h3&gt;

&lt;p&gt;To grasp how Type-safe builders work in Kotlin we need to understand some key Kotlin features and how they can be combined together:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Higher-Order Functions and Lambdas&lt;/strong&gt;: in Kotlin we are allowed to write functions that have &lt;em&gt;functions as parameters or return type&lt;/em&gt; (higher-order functions) and functions that are &lt;em&gt;not declared&lt;/em&gt;, but are passed immediately as an expression (lambdas). Because of this, we can write things like:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// Higher-Order Function
fun transformWith(path: String, function: (String) -&amp;gt; List&amp;lt;String&amp;gt;): List&amp;lt;String&amp;gt; {
    return function(this)
}

// Lambda
{ path: String -&amp;gt; path.split(&amp;quot;/&amp;quot;) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thanks to Kotlin syntactic sugar we can use them in these ways:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;transformWith(&amp;quot;some/path/to&amp;quot;, { path: String -&amp;gt; path.split(&amp;quot;/&amp;quot;) }) // -&amp;gt; [some, path, to]

// Functions which have a function as the last parameter can be written as follow
transformWith(&amp;quot;some/path/to&amp;quot;) { path -&amp;gt; path.split(&amp;quot;/&amp;quot;) } // -&amp;gt; [some, path, to]

// If the lambda has only one parameter it can be ommitted and referenced as &amp;quot;it&amp;quot;
transformWith(&amp;quot;some/path/to&amp;quot;) { it.split(&amp;quot;/&amp;quot;) } // -&amp;gt; [some, path, to]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Extension Functions&lt;/strong&gt;: they allow us to &lt;em&gt;extend&lt;/em&gt; a type with functions without modifying the original class. They are useful to add functionalities to classes we don&amp;rsquo;t have control on or to create utility methods without the need to create &amp;ldquo;Utils classes&amp;rdquo; that contains static methods, as we are used to as Java developers. To continue the previous example we can write:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// Extension function
fun String.transformWith(function: (String) -&amp;gt; List&amp;lt;String&amp;gt;) {
    return function(this)
}

&amp;quot;some/path/to&amp;quot;.transformWith { receiverString: String -&amp;gt; receiverString(&amp;quot;/&amp;quot;) } // -&amp;gt; [some, path, to]

// or more concisely 
&amp;quot;some/path/to&amp;quot;.transformWith { it.split(&amp;quot;/&amp;quot;) } // -&amp;gt; [some, path, to]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that we are referring to the string inside the closure of the extension function using &lt;code&gt;this&lt;/code&gt; as it will be the String object on which the method will be called.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Function Literals with Receiver&lt;/strong&gt;: similarly to extension functions you are also allowed to define functions with a receiver that will be referred to as &lt;code&gt;this&lt;/code&gt; inside the literal closure:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;val transformWith: String.() -&amp;gt; List&amp;lt;String&amp;gt; = { this.split(&amp;quot;/&amp;quot;) }

&amp;quot;some/path/to&amp;quot;.transformWith() // -&amp;gt; [some, path, to]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To better understand function literals with receiver you should think of them as follow: &lt;em&gt;lambda is to normal function as function literal with receiver is to extension function&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// lambda
{ s: String -&amp;gt; s.split(&amp;quot;/&amp;quot;) }
// is to
fun function(s: String): List&amp;lt;String&amp;gt; { return s.split(&amp;quot;/&amp;quot;) }
// as
val functionLiteralWithReceiver = String.() -&amp;gt; List&amp;lt;String&amp;gt; = { this.split(&amp;quot;/&amp;quot;) }
// is to
fun String.extensionFunction(): List&amp;lt;String&amp;gt; { return function(this) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Basically function literals with receiver are extension functions that can be passed to other functions.&lt;/p&gt;

&lt;h3 id=&#34;wrapping-up&#34;&gt;Wrapping up&lt;/h3&gt;

&lt;p&gt;Now we have all the elements required to understand and write a Type-safe builder.&lt;/p&gt;

&lt;p&gt;Combining the above mentioned Kotlin features we can now write a function and name it &lt;code&gt;form&lt;/code&gt;. This function will take as parameter a function literal with receiver usually called &lt;code&gt;init()&lt;/code&gt; and will do the follow:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;create a new Form object&lt;/li&gt;
&lt;li&gt;call &lt;code&gt;init()&lt;/code&gt; on it (that is using it as the receiver of the function literal)&lt;/li&gt;
&lt;li&gt;return the built object to the caller&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;fun form(init: Form.() -&amp;gt; Unit): Form {
    val form = Form() 
    form.init()
    return form
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s imagine that our Form class defines a function &lt;code&gt;field()&lt;/code&gt; that actually creates a field object and adds it to the list of fields contained within the form:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class Form() {
    val fields: List&amp;lt;Field&amp;gt;
    ...
    fun field(key: String) { ... }
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Taking advantage of Kotlin syntactic sugar we can use &lt;code&gt;form()&lt;/code&gt; passing it the &lt;code&gt;init()&lt;/code&gt; function as a lambda and call methods on the Form object to build it as follow:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val builtForm = form() {
    // Here we can take advantage of the compiler and, as a result, of the IDE code completion
    field(&amp;quot;key1&amp;quot;) // == this.field(&amp;quot;key1&amp;quot;) where this is the object create by form()
    field(&amp;quot;key2&amp;quot;)
}
builtForm.getFields() // -&amp;gt; [Field(&amp;quot;key1&amp;quot;), Field(&amp;quot;key2&amp;quot;)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see Type-Safe builders are an &lt;strong&gt;extremely powerful&lt;/strong&gt; and useful feature of Kotlin and they allow you to write very complex DSLs with a &lt;strong&gt;really readable and clear syntax&lt;/strong&gt;. They give you a lot of &lt;strong&gt;flexibility&lt;/strong&gt; letting you combine multiple builders to create a domain language that can meet your requirements.&lt;/p&gt;

&lt;p&gt;If you want to learn more about this subject check out the official &lt;a href=&#34;https://github.com/Kotlin/kotlinx.html&#34;&gt;documentation&lt;/a&gt; or, for example, &lt;a href=&#34;https://github.com/Kotlin/kotlinx.html&#34;&gt;kotlinx&lt;/a&gt;, an official project from the Kotlin team that allows you to create HTML documents with a custom DSL entirely written with Type-safe builders.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>