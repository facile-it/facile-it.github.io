<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Functional Programming on Facile.it Engineering</title>
    <link>https://engineering.facile.it/categories/functional-programming/</link>
    <description>Recent content in Functional Programming on Facile.it Engineering</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 01 Sep 2020 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://engineering.facile.it/categories/functional-programming/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Lambda Days 2020</title>
      <link>https://engineering.facile.it/blog/eng/lambda-days-2020/</link>
      <pubDate>Tue, 01 Sep 2020 00:00:00 +0000</pubDate>
      <guid>https://engineering.facile.it/blog/eng/lambda-days-2020/</guid>
      <description>&lt;p&gt;This year, Facile attended for the first time &lt;a href=&#34;https://www.lambdadays.org/lambdadays2020&#34;&gt;Lambda Days&lt;/a&gt; Conference in the beautiful polish city of Krakow.&#xA;It has been a two-days full immersion with speakers coming from all over the world.&#xA;The latest trends and academic research in the functional world were showcased, spanning from beginner&amp;rsquo;s approaches to functional languages to highly specific scientific applications.&#xA;This conference was totally worth attending, albeit very intense (sometimes mind-bending, actually!). All the talks were of high quality and the organization was perfect.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Please mutate responsibly: 3 ways to improve your mutable objects</title>
      <link>https://engineering.facile.it/blog/eng/please-mutate-responsibly-3-ways-to-improve-your-mutable-objects/</link>
      <pubDate>Mon, 12 Dec 2016 00:00:00 +0000</pubDate>
      <guid>https://engineering.facile.it/blog/eng/please-mutate-responsibly-3-ways-to-improve-your-mutable-objects/</guid>
      <description>&lt;p&gt;Maintaining &lt;strong&gt;state&lt;/strong&gt; is the main cause of complexity and headaches in software development: without a careful consideration of state, our projects will inevitably become impossible to understand. In fact, various development techniques and programming styles are mainly there to handle state in a responsible way: for example, &lt;a href=&#34;https://en.wikipedia.org/wiki/Monad_(functional_programming)&#34;&gt;&lt;strong&gt;monads&lt;/strong&gt;&lt;/a&gt;, as used in functional programming, are often employed for this very task. A good general way of managing state is trying to make it &lt;strong&gt;immutable&lt;/strong&gt;, either through the use &lt;a href=&#34;https://en.wikipedia.org/wiki/Value_type&#34;&gt;value types&lt;/a&gt;, that is, types which instances are passed around with &lt;a href=&#34;https://en.wikipedia.org/wiki/Object_copying#Deep_copy&#34;&gt;deep copy&lt;/a&gt; semantics, or simple &lt;em&gt;immutable objects&lt;/em&gt;, which have reference semantics but because they&amp;rsquo;re immutable their state is fixed.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Decoupling view controllers with Signals</title>
      <link>https://engineering.facile.it/blog/eng/decoupling-view-controllers-with.signals/</link>
      <pubDate>Tue, 15 Mar 2016 00:00:00 +0000</pubDate>
      <guid>https://engineering.facile.it/blog/eng/decoupling-view-controllers-with.signals/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://engineering.facile.it/code-reuse-a-primer/&#34;&gt;Last time&lt;/a&gt; we looked at the &lt;strong&gt;Signal&lt;/strong&gt; class, that is, a simple, reusable way of encapsulating the &lt;a href=&#34;https://en.wikipedia.org/wiki/Observer_pattern&#34;&gt;observer pattern&lt;/a&gt;. There are many use cases for a signal, and I&amp;rsquo;m going to show one possible application, spawned from a real-world problem. View controllers&amp;rsquo; composition and decoupling is &lt;strong&gt;hard&lt;/strong&gt;: we often need an input from a view controller, that has to send its input back to its creator, while handling the back navigation somehow. We often find ourselves in a situation in which several different responsibilities are all expressed in a single view controller, with the effect of creating a gigantic class, full of entangled imperative statements, hard-to-understand sequencing and general complexity. We&amp;rsquo;ll use the &lt;code&gt;Signal&lt;/code&gt; class to assign the various responsibilities to different classes, and write cleaner, more declarative code. The core of this architectural pattern lies in inverting the way in which objects communicate, view controller or other: instead of asking objects to do things, we&amp;rsquo;re going to &lt;strong&gt;observe&lt;/strong&gt; what objects are doing, and &lt;strong&gt;react&lt;/strong&gt; accordingly. &lt;em&gt;Observe&lt;/em&gt; and &lt;em&gt;React&lt;/em&gt; are the cornerstones of the programming paradigm known as &lt;a href=&#34;https://en.wikipedia.org/wiki/Functional_reactive_programming&#34;&gt;functional reactive programming(FRP)&lt;/a&gt;; the present article is not going to talk about FRP as a whole, nor to present shared FRP techniques; the point is to discuss an architectural pattern for decoupling view controllers from responsibilities not strictly related to user interaction, by leveraging some basic FRP tools.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Code reuse: a primer</title>
      <link>https://engineering.facile.it/blog/eng/code-reuse-a-primer/</link>
      <pubDate>Wed, 09 Dec 2015 00:00:00 +0000</pubDate>
      <guid>https://engineering.facile.it/blog/eng/code-reuse-a-primer/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://engineering.facile.it/optionals-in-objective-c/&#34;&gt;Last time&lt;/a&gt; we looked at a possible implementation for the &lt;a href=&#34;https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID330&#34;&gt;Optional&lt;/a&gt; type in Objective-C; while the main point was to port to Objective-C a tool that&amp;rsquo;s frequently used in Swift, making use of the &lt;code&gt;Optional&lt;/code&gt; class can be considered an application of a much more general concept: &lt;strong&gt;code reuse&lt;/strong&gt;. In fact, &lt;code&gt;Optional&lt;/code&gt; is not tied to a particular domain, and can be reused over and over again in multiple projects: that&amp;rsquo;s what actually happens in Swift. But, to think about it, that&amp;rsquo;s what happens for a wide range of &lt;em&gt;classes&lt;/em&gt; in Objective-C, or &lt;em&gt;types&lt;/em&gt; in Swift: for example, &lt;code&gt;NSArray&lt;/code&gt; and &lt;code&gt;Array&lt;/code&gt; are both constructs that expose a certain interface, have a certain implementation, and are reused multiple times within methods and functions. And again, &lt;code&gt;NSArray&lt;/code&gt; and &lt;code&gt;Array&lt;/code&gt; are not tied to a particular domain, and have two important properties:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Codice riusabile: un primer</title>
      <link>https://engineering.facile.it/blog/ita/codice-riusabile-un-primer/</link>
      <pubDate>Wed, 09 Dec 2015 00:00:00 +0000</pubDate>
      <guid>https://engineering.facile.it/blog/ita/codice-riusabile-un-primer/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://engineering.facile.it/optionals-in-objective-c-ita/&#34;&gt;L&amp;rsquo;ultima volta&lt;/a&gt; abbiamo visto una possibile implementazione del tipo &lt;a href=&#34;https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID330&#34;&gt;Optional&lt;/a&gt; in Objective-C; l&amp;rsquo;obiettivo primario dell&amp;rsquo;articolo era quello di importare in Objective-C uno strumento frequentemente utilizzato in Swift, ma usare una classe come &lt;code&gt;Optional&lt;/code&gt; può essere considerato un&amp;rsquo;applicazione di un concetto molto più generale: il &lt;strong&gt;riutilizzo del codice&lt;/strong&gt;. In effetti, &lt;code&gt;Optional&lt;/code&gt; non è legato a un particolare dominio, e può essere riutilizzato più e più volte in molti progetti: questo è esattamente ciò che accade in Swift. Ma a pensarci bene, questo è ciò che accade per una grande varietà di &lt;em&gt;classi&lt;/em&gt; in Objective-C (e di &lt;em&gt;tipi&lt;/em&gt; in Swift): ad esempio, &lt;code&gt;NSArray&lt;/code&gt; e &lt;code&gt;Array&lt;/code&gt; sono entrambi costrutti che espongono una specifica interfaccia, possiedono una certa implementazione, e vengono riutilizzati continuamente in metodi e funzioni. &lt;code&gt;NSArray&lt;/code&gt; e &lt;code&gt;Array&lt;/code&gt; non sono legati a un particolare dominio, e possiedono due importanti caratteristiche:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Optionals in Objective-C</title>
      <link>https://engineering.facile.it/blog/eng/optionals-in-objective-c/</link>
      <pubDate>Mon, 09 Nov 2015 00:00:00 +0000</pubDate>
      <guid>https://engineering.facile.it/blog/eng/optionals-in-objective-c/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Objective-C is not going anywhere&lt;/strong&gt;. While Swift is most certainly the new hotness for iOS and OS X programming, there are some concrete reasons to stick with Objective-C for a while:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Objective-C based projects still need maintenance and new features to be added, and mixing Swift and Objective-C, while possible, &lt;strong&gt;can be tricky&lt;/strong&gt; and possibly unconvenient, due to the dynamic nature of the latter;&lt;/li&gt;&#xA;&lt;li&gt;Swift is changing rapidly, has still some bugs and &lt;strong&gt;performance problems&lt;/strong&gt;, and still lacks some features that professionals need, while Objective-C is mature and has a strong community;&lt;/li&gt;&#xA;&lt;li&gt;some may &lt;strong&gt;prefer a more dynamic language&lt;/strong&gt;, and Objective-C support from Apple &lt;a href=&#34;https://netguru.co/blog/objective-c-generics&#34;&gt;is still strong&lt;/a&gt;;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Personally, while I naturally lean towards a more static, &lt;a href=&#34;http://engineering.facile.it/type-first-development-in-swift/&#34;&gt;type-first&lt;/a&gt; approach to programming, from time to time I like to work in a more dynamic environment, so both for preference and for business needs, I still didn&amp;rsquo;t put Objective-C completely away. But just after a few weeks of Swift I found myself missing one of the most powerful features of the language: &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID330&#34;&gt;Optionals&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Optionals in Objective-C</title>
      <link>https://engineering.facile.it/blog/ita/optionals-in-objective-c/</link>
      <pubDate>Mon, 09 Nov 2015 00:00:00 +0000</pubDate>
      <guid>https://engineering.facile.it/blog/ita/optionals-in-objective-c/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Objective-C vivrà ancora per molto&lt;/strong&gt;. Nonostante Swift sia il nuovo punto di riferimento per lo sviluppo iOS e OS X, ci sono ragioni concrete per scegliere di continuare a sviluppare in Objective-C, almeno per un po&#39;:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;progetti esistenti basati su Objective-C richiedono ancora mantenimento e probabile aggiunta di nuove funzionalità, e anche se è tecnicamente possibile mescolare i linguaggi, la cosa può risultare &lt;strong&gt;poco conveniente&lt;/strong&gt; per via della natura molto dinamica di Objective-C;&lt;/li&gt;&#xA;&lt;li&gt;Swift sta cambiando rapidamente, presenta ancora alcuni bug e &lt;strong&gt;problemi di performance&lt;/strong&gt;, e il suo workflow manca ancora di alcune feature fondamentali per i professionisti, mentre Objective-C è un linguaggio maturo, con una community molto vivace;&lt;/li&gt;&#xA;&lt;li&gt;alcuni possono &lt;strong&gt;preferire un linguaggio più dinamico&lt;/strong&gt;, e il supporto di Apple su Objective-C è &lt;a href=&#34;https://netguru.co/blog/objective-c-generics&#34;&gt;ancora forte&lt;/a&gt;;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Personalmente ho la tendenza a preferire linguaggi più statici, e un approccio &lt;a href=&#34;http://engineering.facile.it/type-first-development-in-swift/&#34;&gt;type-first&lt;/a&gt; alla programmazione, ma di tanto in tanto mi piace lavorare in un ambiente più &lt;em&gt;dinamico&lt;/em&gt;, quindi, sia per preferenza personale che per esigenze di business, non ho ancora messo Objective-C da parte. Ma dopo poche settimane di Swift, mi è mancata subito una delle sue funzionalità più potenti: gli &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID330&#34;&gt;Optionals&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>No Country For If Else</title>
      <link>https://engineering.facile.it/blog/eng/no-country-for-if-else/</link>
      <pubDate>Tue, 15 Sep 2015 00:00:00 +0000</pubDate>
      <guid>https://engineering.facile.it/blog/eng/no-country-for-if-else/</guid>
      <description>&lt;p&gt;There is an &lt;strong&gt;unwanted guest&lt;/strong&gt; with us as we write code and build software projects: it&amp;rsquo;s the code that&amp;rsquo;s &lt;strong&gt;already written&lt;/strong&gt;, and we must take into account its complexity as the code base increases in size. High complexity of the existing code can make the following activities particularly difficult:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;understanding the meaning of old code, written by others or ourselves;&lt;/li&gt;&#xA;&lt;li&gt;tracing the causes of bugs, i.e. errors, in code;&lt;/li&gt;&#xA;&lt;li&gt;making changes to a certain procedure;&lt;/li&gt;&#xA;&lt;li&gt;adding features to existing structures;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Even if we approach the development of new software with &lt;a href=&#34;https://en.wikipedia.org/wiki/Agile_software_development&#34;&gt;agile methodologies&lt;/a&gt;, we always have to deal with the existing code, and to do that we must at least be able to &lt;strong&gt;understand it without overexertion&lt;/strong&gt;. So when I talk about &lt;em&gt;complexity&lt;/em&gt; I am referring in particular to the difficulty with which a programmer can &lt;em&gt;reason about&lt;/em&gt; the existing code: the preface of the well-known academic textbook &lt;a href=&#34;http://deptinfo.unice.fr/~roy/sicp.pdf&#34;&gt;Structure and Interpretation of Computer Programs&lt;/a&gt; contains the following sentence:&lt;/p&gt;</description>
    </item>
    <item>
      <title>No Country For If Else</title>
      <link>https://engineering.facile.it/blog/ita/no-country-for-if-else/</link>
      <pubDate>Tue, 15 Sep 2015 00:00:00 +0000</pubDate>
      <guid>https://engineering.facile.it/blog/ita/no-country-for-if-else/</guid>
      <description>&lt;p&gt;C&amp;rsquo;è un &lt;strong&gt;ospite indesiderato&lt;/strong&gt; che ci accompagna sempre mentre scriviamo codice e realizziamo progetti software: si tratta del &lt;strong&gt;codice già esistente&lt;/strong&gt;, e dobbiamo tener conto della sua complessità man mano che la &lt;em&gt;code base&lt;/em&gt; aumenta di dimensioni. Un&amp;rsquo;elevata complessità del codice può rendere le seguenti attività particolarmente difficili:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;comprendere il significato di codice vecchio, scritto da altri o da se stessi;&lt;/li&gt;&#xA;&lt;li&gt;tracciare le cause di bug, cioè errori, nel codice;&lt;/li&gt;&#xA;&lt;li&gt;eseguire modifiche a una certa procedura;&lt;/li&gt;&#xA;&lt;li&gt;aggiungere funzionalità a strutture già esistenti;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Anche approcciando lo sviluppo di nuovo software con &lt;a href=&#34;https://en.wikipedia.org/wiki/Agile_software_development&#34;&gt;metodologie agili&lt;/a&gt;, dobbiamo comunque fare i conti con il codice esistente, e per farlo dobbiamo almeno essere in grado di &lt;strong&gt;comprenderlo senza sforzi eccessivi&lt;/strong&gt;. Dunque quando parlo di &lt;em&gt;complessità&lt;/em&gt; mi riferisco in particolare alla difficoltà con la quale una programmatore è in grado di &lt;em&gt;ragionare&lt;/em&gt; sul codice. La prefazione del noto testo accademico &lt;a href=&#34;http://deptinfo.unice.fr/~roy/sicp.pdf&#34;&gt;Structure and interpretation of computer programs&lt;/a&gt; contiene la seguente frase:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Programmazione Funzionale: perché preoccuparsi?</title>
      <link>https://engineering.facile.it/blog/ita/programmazione-funzionale-perche-preoccuparsi/</link>
      <pubDate>Mon, 13 Jul 2015 00:00:00 +0000</pubDate>
      <guid>https://engineering.facile.it/blog/ita/programmazione-funzionale-perche-preoccuparsi/</guid>
      <description>&lt;p&gt;Nel suo discorso di accettazione del &lt;a href=&#34;http://amturing.acm.org/award_winners/dijkstra_1053701.cfm&#34;&gt;Premio Turing 1972&lt;/a&gt;, dal titolo &amp;ldquo;&lt;a href=&#34;https://www.cs.utexas.edu/~EWD/transcriptions/EWD03xx/EWD340.html&#34;&gt;The humble programmer&lt;/a&gt;&amp;rdquo;, &lt;strong&gt;Edsger Wybe Dijkstra&lt;/strong&gt;, uno dei più celebri &lt;em&gt;computing scientists&lt;/em&gt; del 20° secolo (morto nel 2002), affrontò le cause della nota &lt;a href=&#34;https://it.wikipedia.org/wiki/Software_crisis&#34;&gt;Software Crisis&lt;/a&gt;, cioè la crisi che colpì l&amp;rsquo;industria del software nella seconda metà degli anni sessanta: la potenza e la capacità di elaborazione dei computer stavano &lt;strong&gt;crescendo esponenzialmente&lt;/strong&gt;, molto più rapidamente dell&amp;rsquo;abilità dei programmatori di &lt;strong&gt;gestire la complessità&lt;/strong&gt; e scrivere software funzionante. Nello stesso discorso, Dijkstra propose anche delle possibili strade da intraprendere che a suo avviso avrebbero portato aziende e università a migliorare la qualità del loro software. Riporto qui una frase che a mio parere riassume abbastanza bene l&amp;rsquo;intero discorso:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Type First Development in Swift</title>
      <link>https://engineering.facile.it/blog/ita/type-first-development-in-swift/</link>
      <pubDate>Tue, 05 May 2015 00:00:00 +0000</pubDate>
      <guid>https://engineering.facile.it/blog/ita/type-first-development-in-swift/</guid>
      <description>&lt;p&gt;Con &lt;em&gt;Type First Development&lt;/em&gt; può intendersi un approccio allo sviluppo di nuove funzionalità o moduli di un software partendo dai &lt;strong&gt;tipi&lt;/strong&gt; di dati coinvolti: non si tratta quindi di un pattern o una pratica codificata, ma solo di &lt;strong&gt;un possibile punto di partenza&lt;/strong&gt; per iniziare il ragionamento. Ragionando esclusivamente sui tipi, prima ancora di pensare alle singole specifiche implementazioni dei vari blocchi di codice, è possibile costruire più facilmente una mappa dei vari di flussi di dati che attraversano il nostro software, e verificare immediatamente se stiamo scrivendo qualcosa di sensato, solido ed adeguatamente estendibile.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
