<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>OOP on Facile.it Engineering</title>
    <link>https://engineering.facile.it/categories/oop/</link>
    <description>Recent content in OOP on Facile.it Engineering</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 12 Mar 2021 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://engineering.facile.it/categories/oop/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Careful with that constant, developer</title>
      <link>https://engineering.facile.it/blog/eng/careful-with-that-constant-developer/</link>
      <pubDate>Fri, 12 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://engineering.facile.it/blog/eng/careful-with-that-constant-developer/</guid>
      <description>Introduction Imagine you need to use a fixed numeric value in your code, let&amp;rsquo;s say 20000. It is what we call a literal constant, that is a value that will always remain the exact same in your code.
Now imagine you need to use that value more than once. Sooner or later you will read your code and you will not remember what 20000 was, it will happen for sure. But what if you assign the value to an immutable variable with a meaningful name?</description>
    </item>
    
    <item>
      <title>From zero to infinite: the Final keyword</title>
      <link>https://engineering.facile.it/blog/eng/from-zero-to-infinite-the-final-keyword/</link>
      <pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://engineering.facile.it/blog/eng/from-zero-to-infinite-the-final-keyword/</guid>
      <description>Google from zero to infinite Sometimes I do a full immersion on topics of my interest, generally related to programming, topics on testing, good design, etc. I apply a technique invented by me named: &amp;ldquo;Google from zero to infinite&amp;rdquo;.
Basically I use one or more keywords in Google, then I literally follow all the links of all the pages. It is a very long and laborious activity. However, most of the time I find very interesting documents, otherwise difficult to reach.</description>
    </item>
    
    <item>
      <title>Why type hints and interfaces are not visual debt</title>
      <link>https://engineering.facile.it/blog/eng/visual-debt-typehints/</link>
      <pubDate>Wed, 31 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://engineering.facile.it/blog/eng/visual-debt-typehints/</guid>
      <description>A few days ago I stumbled on a strange tweet that was highlighting a controversy about scalar type hints.
Scalar type hints &amp;amp; return types vs no scalar type hints &amp;amp; return types is #PHP&amp;#39;s new spaces vs tabs
&amp;mdash; Cees-Jan üîä Kiewiet (@WyriHaximus) 19 maggio 2017  After asking references about this, someone alluded to this very short video: &amp;ldquo;PHP Bits: Visual Debt&amp;rdquo; (it&amp;rsquo;s only 3 minutes, please watch it before continue reading).</description>
    </item>
    
    <item>
      <title>Please mutate responsibly: 3 ways to improve your mutable objects</title>
      <link>https://engineering.facile.it/blog/eng/please-mutate-responsibly-3-ways-to-improve-your-mutable-objects/</link>
      <pubDate>Mon, 12 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>https://engineering.facile.it/blog/eng/please-mutate-responsibly-3-ways-to-improve-your-mutable-objects/</guid>
      <description>Maintaining state is the main cause of complexity and headaches in software development: without a careful consideration of state, our projects will inevitably become impossible to understand. In fact, various development techniques and programming styles are mainly there to handle state in a responsible way: for example, monads, as used in functional programming, are often employed for this very task. A good general way of managing state is trying to make it immutable, either through the use value types, that is, types which instances are passed around with deep copy semantics, or simple immutable objects, which have reference semantics but because they&amp;rsquo;re immutable their state is fixed.</description>
    </item>
    
    <item>
      <title>No Country For If Else</title>
      <link>https://engineering.facile.it/blog/eng/no-country-for-if-else/</link>
      <pubDate>Tue, 15 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>https://engineering.facile.it/blog/eng/no-country-for-if-else/</guid>
      <description>There is an unwanted guest with us as we write code and build software projects: it&amp;rsquo;s the code that&amp;rsquo;s already written, and we must take into account its complexity as the code base increases in size. High complexity of the existing code can make the following activities particularly difficult:
 understanding the meaning of old code, written by others or ourselves; tracing the causes of bugs, i.e. errors, in code; making changes to a certain procedure; adding features to existing structures;  Even if we approach the development of new software with agile methodologies, we always have to deal with the existing code, and to do that we must at least be able to understand it without overexertion.</description>
    </item>
    
    <item>
      <title>No Country For If Else</title>
      <link>https://engineering.facile.it/blog/ita/no-country-for-if-else/</link>
      <pubDate>Tue, 15 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>https://engineering.facile.it/blog/ita/no-country-for-if-else/</guid>
      <description>C&#39;√® un ospite indesiderato che ci accompagna sempre mentre scriviamo codice e realizziamo progetti software: si tratta del codice gi√† esistente, e dobbiamo tener conto della sua complessit√† man mano che la code base aumenta di dimensioni. Un&amp;rsquo;elevata complessit√† del codice pu√≤ rendere le seguenti attivit√† particolarmente difficili:
 comprendere il significato di codice vecchio, scritto da altri o da se stessi; tracciare le cause di bug, cio√® errori, nel codice; eseguire modifiche a una certa procedura; aggiungere funzionalit√† a strutture gi√† esistenti;  Anche approcciando lo sviluppo di nuovo software con metodologie agili, dobbiamo comunque fare i conti con il codice esistente, e per farlo dobbiamo almeno essere in grado di comprenderlo senza sforzi eccessivi.</description>
    </item>
    
  </channel>
</rss>