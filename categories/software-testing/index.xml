<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Software testing on Facile.it Engineering</title>
    <link>https://engineering.facile.it/categories/software-testing/</link>
    <description>Recent content in Software testing on Facile.it Engineering</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 31 May 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://engineering.facile.it/categories/software-testing/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Why type hints and interfaces are not visual debt</title>
      <link>https://engineering.facile.it/blog/eng/visual-debt-typehints/</link>
      <pubDate>Wed, 31 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://engineering.facile.it/blog/eng/visual-debt-typehints/</guid>
      <description>

&lt;p&gt;A few days ago I stumbled on a strange tweet that was highlighting a controversy about scalar type hints.&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;it&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;Scalar type hints &amp;amp; return types vs no scalar type hints &amp;amp; return types is &lt;a href=&#34;https://twitter.com/hashtag/PHP?src=hash&#34;&gt;#PHP&lt;/a&gt;&amp;#39;s new spaces vs tabs&lt;/p&gt;&amp;mdash; Cees-Jan üîä Kiewiet (@WyriHaximus) &lt;a href=&#34;https://twitter.com/WyriHaximus/status/865524687257862144&#34;&gt;19 maggio 2017&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;After asking references about this, someone alluded to this very short video: &lt;a href=&#34;https://laracasts.com/series/php-bits/episodes/1&#34;&gt;&lt;strong&gt;&amp;ldquo;PHP Bits: Visual Debt&amp;rdquo;&lt;/strong&gt;&lt;/a&gt; (it&amp;rsquo;s only 3 minutes, please watch it before continue reading). After that, the author of the video was dragged into the conversation, and it blew up into a big tweetstorm in the following few hours.&lt;/p&gt;

&lt;p&gt;The core of the controversy was the fact that the author of the video classified as &lt;strong&gt;&lt;em&gt;visual debt&lt;/em&gt;&lt;/strong&gt; a lot of stuff in his PHP example, like interfaces, scalar type hints and the final keyword.&lt;/p&gt;

&lt;h2 id=&#34;my-opinion-on-the-matter&#34;&gt;My opinion on the matter&lt;/h2&gt;

&lt;p&gt;I can agree with the bottom line of the video:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Am I necessarily getting a benefit [&amp;hellip;] ?  Question everything&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Every choice in our line of work is always a &lt;strong&gt;trade-off&lt;/strong&gt; between benefits and cons, and every new introduction in a projects should be evaluated and agreed upon between team members. But my personal preference leans a lot towards the opposite side in this specific matter: as I stated in a &lt;a href=&#34;https://engineering.facile.it/blog/eng/how-php-7-tdd-helped-me-sleep-better/&#34;&gt;previous blog post here&lt;/a&gt;, I love the new additions that PHP 7 brought to us like scalar and return type hints, and I use them as often as I can, because I discovered that &lt;strong&gt;they bring a lot of benefits&lt;/strong&gt; to the code that I write.&lt;/p&gt;

&lt;p&gt;Probably this was influenced by the fact that previously I worked with C++, where types are a lot more intrusive compared with PHP 5; but over time and with usage, I learned the great benefits that we can achieve with this addition to our PHP 7 codebases. In general, I think that type hints, and other language features that create a more &amp;ldquo;rigid&amp;rdquo; code, are &lt;strong&gt;helpful during the evolution of a codebase&lt;/strong&gt;, and so they are really needed in long-running projects, where the maintainability of code is crucial. It may be less true in a &amp;ldquo;release and forget&amp;rdquo; type of project, but I think that it would still be like betting againt oneself.&lt;/p&gt;

&lt;p&gt;In this blog post I would like to explain myself and the reasons behind my arguments, recounting them.&lt;/p&gt;

&lt;h2 id=&#34;scalar-type-hints-as-safeguards&#34;&gt;Scalar type hints as safeguards&lt;/h2&gt;

&lt;p&gt;In the video, the example had all along this class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class Event implements EventInterface
{
    protected $events = [];
    
    public function listen(string $name, callable $handler): void
    {
        $this-&amp;gt;events[$name][] = $handler;
    }

    public function fire(string $name): bool
    {
        if (! array_key_exists($name, $this-&amp;gt;events)) {
            return false;
        }
        
        foreach($this-&amp;gt;events[$name] as $event) {
            $event();
        }

        return true;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The author suggests to remove all type hints, since the code should still work and you could get rid of a lot of additional, not needed complications. I disagree completely with this.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Type hints are safeguards&lt;/strong&gt; here, because they let you reduce to the bare minimum all the checks that you should do here before accepting the input arguments:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;because it&amp;rsquo;s used as a key for an array, &lt;code&gt;$name&lt;/code&gt; can only be a string (or an int, but it would not make sense)&lt;/li&gt;
&lt;li&gt;the &lt;code&gt;events&lt;/code&gt; property can only accept callables, because its elements are invoked inside the foreach of the &lt;code&gt;fire()&lt;/code&gt; method&lt;/li&gt;
&lt;li&gt;because we don&amp;rsquo;t need to insert additional &lt;code&gt;if&lt;/code&gt;s in our methods, we &lt;strong&gt;reduce the number of possible paths of execution&lt;/strong&gt;, hence reducing the number of cases that we need to check in our tests.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;type-hints-and-interfaces-as-contracts&#34;&gt;Type hints and interfaces as contracts&lt;/h2&gt;

&lt;p&gt;In the video, it was suggested to also get rid of the interface:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;interface EventInterface
{
    public function listen(string $name, callable $handler): void;

    public function fire(string $name): bool;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I agree that &lt;strong&gt;an interface should be written only if needed&lt;/strong&gt;, like if you want to write multiple concrete implementation of it with different inheritance hierarchy. But this doesn&amp;rsquo;t mean that we will not have any interface at all: we still have the concrete implementation.&lt;/p&gt;

&lt;p&gt;That is not the same of having a pure interface, but we will still be able to determine a &lt;strong&gt;contract&lt;/strong&gt;, a list of method signatures that tells us what that object will accept as valid method calls. This kind of contracts are a must in object oriented programming, because they dictate how your object will interconnect, communicate and cooperate, and they are especially useful in combination with stricter type hints and &lt;strong&gt;unit testing&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;When we write unit test, we use the real instance of the class which is under test, and everything else should be mocked. That means that we will use some test mocking library (i.e. I prefer &lt;a href=&#34;https://github.com/phpspec/prophecy&#34;&gt;Prophecy&lt;/a&gt;, which is included in PHPUnit) to mimick the behavior of nearby objects.&lt;/p&gt;

&lt;p&gt;How type hints would help us in this case? If we would have to mock the &lt;code&gt;EventInterface&lt;/code&gt; (or the concrete class, it&amp;rsquo;s unimportant here), having the return type hints for example would help us in &lt;strong&gt;writing good mocks&lt;/strong&gt;, and not wrong ones.&lt;/p&gt;

&lt;p&gt;But how? Nearly every mocking library creates a mock extending at runtime the original class, since the mock needs to pass every check and type hint as if it was the original class; this means that it can&amp;rsquo;t change the method signature, hence preserving the original return type hint.&lt;/p&gt;

&lt;p&gt;This will translate in errors and test failures if we would write a mock that doesn&amp;rsquo;t return the proper type, like in this example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class Person
{
    public function shout(): bool
    {
        $event = new Event();
        if ($event-&amp;gt;fire(&#39;shout&#39;)) {
            // someone was listening!
            return true;
        }
        // ...
    }
}

class PersonTest extends PHPUnit\Framework\TestCase
{
    public function testShout()
    {
        $event = $this-&amp;gt;prophesize(EventInterface::class);
        $event-&amp;gt;fire(&#39;shout&#39;)
            -&amp;gt;shouldBeCalled();
        // ...
        
        $person = new Person();
        $person-&amp;gt;shout();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ phpunit
# ...
1) PersonTest::testShout
TypeError: Return value of Double\EventInterface\P2118::fire() must be a string, null returned
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This mock, once used, &lt;strong&gt;will make the test fail&lt;/strong&gt;. Why? Because the &lt;code&gt;fire()&lt;/code&gt; method can only return a boolean, and by default (if not instructed differently) Prophecy&amp;rsquo;s mocks will return &lt;code&gt;null&lt;/code&gt;. Without the &lt;code&gt;: bool&lt;/code&gt; return type hint, the mock would return &lt;code&gt;null&lt;/code&gt; but the test would not fail, and the class under test would silently cast or interpret the return value as &lt;code&gt;false&lt;/code&gt;, possibly causing an unintended behavior or a false positive.&lt;/p&gt;

&lt;p&gt;This means that having complete type hints in your interfaces and method signatures only &lt;strong&gt;makes your code more cohesive and your unit test more robust&lt;/strong&gt;; this kind of enforcing helps a lot also with refactoring, since changing a method&amp;rsquo;s signature would cause failures in all the related tests that include a mock of that interface, as it could become inconsistent and unreliable after this change.&lt;/p&gt;

&lt;h2 id=&#34;use-interfaces-as-behavior-checks&#34;&gt;Use interfaces as behavior checks&lt;/h2&gt;

&lt;p&gt;One of the counter example that popped up during the discussion on Twitter was this one:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class Fireman
{
    // ...
}

class Building
{
    public function putOutFire(Fireman $fireman);
}

$building-&amp;gt;putOutFire(new StrongAndAblePerson()); // type error!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This was cited to show how sometimes type hints can be a hindrance more that something helpful in your code: why a strong, capable person shouldn&amp;rsquo;t be able to put out a fire? Who&amp;rsquo;s the &lt;code&gt;Building&lt;/code&gt; class to decide that? Are we maybe violating the Single Responsibility Principle?&lt;/p&gt;

&lt;p&gt;I think that this is misguided for a simple reason: it was &lt;strong&gt;wrong to check against a concrete implementation&lt;/strong&gt; instead of an interface; and that&amp;rsquo;s not evident because, in my opinion, the example was &lt;strong&gt;cut too short&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s speculate on the content of the &lt;code&gt;putOutFire()&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class Building
{
    public function putOutFire(Fireman $fireman)
    {
        $fireman-&amp;gt;wearProtectiveGear();
        $fireman-&amp;gt;shootWaterAtFlames();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Why we have a type hint in the &lt;code&gt;putOutFire()&lt;/code&gt; method? Surely because we want to rely on some method that a &lt;code&gt;Fireman&lt;/code&gt; instance would give to us in the method body (i.e. the &lt;code&gt;wearProtectiveGear()&lt;/code&gt; and &lt;code&gt;shootWaterAtFlames()&lt;/code&gt;); if we remove the type hint, we would have no guarantees that those methods exists on the argument, and we would have to either use a &lt;code&gt;method_exists()&lt;/code&gt; call twice (oh, the horror!) or expose our &lt;code&gt;Building&lt;/code&gt; class to a possible fatal error.&lt;/p&gt;

&lt;p&gt;To take the example further, we can make the &lt;code&gt;StrongAndAblePerson&lt;/code&gt; capable of put out a fire if we &lt;strong&gt;extract the needed methods in an interface&lt;/strong&gt;, defining a contract of what our &lt;code&gt;putOutFire()&lt;/code&gt; needs to know and use:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;interface TrainedFireFighter
{
    public function wearProtectiveGear(): void;
    public function shootWaterAtFlames(): void;
}

class StrongAndAblePerson implements TrainedFireFighter { ... }
class Fireman implements TrainedFireFighter { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip; now we can have the &lt;code&gt;putOutFire()&lt;/code&gt; method with a broader type hint, that would accept both a &lt;code&gt;Fireman&lt;/code&gt; and any other class that implements the &lt;code&gt;TrainedFireFighter&lt;/code&gt; interface:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class Building
{
    public function putOutFire(TrainedFireFighter $firefighter)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;the-final-keyword&#34;&gt;The final keyword&lt;/h2&gt;

&lt;p&gt;The only point of the video which I find relatable is the remark on the &lt;code&gt;final&lt;/code&gt; keyword.&lt;/p&gt;

&lt;p&gt;Apart from the funny joke (&lt;em&gt;&amp;ldquo;I&amp;rsquo;m not your daddy!&amp;rdquo;&lt;/em&gt;), I find the final keyword &lt;strong&gt;not very usable in closed projects&lt;/strong&gt;, since its only usefulness is to impede the extension of some object. When the persons that could work on a codebase are well known and they can be coordinated, I think it&amp;rsquo;s better to leave that liberty to the coders, and just have an agreement on what can and cannot be done with that class.&lt;/p&gt;

&lt;p&gt;On the other hand, this keyword becomes useful when we are talking about &lt;strong&gt;open sourced code&lt;/strong&gt;: using it is a clear statement that reduces the surface of the API that the library is exposing to end users, in the same way &lt;code&gt;private&lt;/code&gt; is limiting access to properties.&lt;/p&gt;

&lt;p&gt;Straightforwardly, the maintainer of the code is saying that this class is not extensible, because it may change internally without notice; this concept is also well explained by Marco Pivetta in his signature &amp;ldquo;Extremely defensive PHP&amp;rdquo; talk (which we cited also in our &lt;a href=&#34;https://engineering.facile.it/blog/eng/php-day-2017/&#34;&gt;previous blog post&lt;/a&gt;, &lt;a href=&#34;https://ocramius.github.io/extremely-defensive-php/#/90&#34;&gt;see related slide here&lt;/a&gt;) and &lt;a href=&#34;http://ocramius.github.io/blog/when-to-declare-classes-final/&#34;&gt;in his blog post about it&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;a-practical-example&#34;&gt;A practical example&lt;/h2&gt;

&lt;p&gt;I would like to conclude this blog post with a practical example. I maintain &lt;a href=&#34;https://github.com/facile-it/paraunit/&#34;&gt;facile-it/paraunit&lt;/a&gt;, a parallelization tool that works on top of PHPUnit. In the past few days I was working on supporting PHPUnit v6, and that lead to bumping the minimum PHP supported version of the package to 7.0: &lt;a href=&#34;https://github.com/facile-it/paraunit/pull/93&#34;&gt;https://github.com/facile-it/paraunit/pull/93&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Since previously the minimum supported version was PHP 5.3, I took the opportunity to go over the whole codebase and clean it up, using all the new language features that I could now take for granted: &lt;code&gt;::class&lt;/code&gt; shortcuts, array short syntax, but more importantly the aforementioned &lt;strong&gt;scalar and return type hints&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;This is the perfect example to show that adding those type hints on already working code made a &lt;strong&gt;non-trivial difference&lt;/strong&gt; even if I wasn&amp;rsquo;t changing the objects&amp;rsquo; behavior, and it forced me to fix some of this stuff:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;it forced me &lt;a href=&#34;https://github.com/facile-it/paraunit/pull/93/files#diff-049f05e192bb0dcb9cf59ad2bbd43ceaR79&#34;&gt;to define more explicitly a default behavior&lt;/a&gt;, since a &lt;code&gt;null&lt;/code&gt; was no longer accepted in place of a string&lt;/li&gt;
&lt;li&gt;this also lead me to &lt;a href=&#34;https://github.com/facile-it/paraunit/pull/93/commits/6aa9286256ed47c7b4500b990e030588b18b7770&#34;&gt;write an additional test&lt;/a&gt; for an uncovered, very common case&lt;/li&gt;
&lt;li&gt;it made me realize that I had &lt;a href=&#34;https://github.com/facile-it/paraunit/pull/93/files#diff-f3225dfaa1d4e63e21a7e51880c63bbbR40&#34;&gt;a regex silently failing&lt;/a&gt; returning a bad result, and I had to take better care of it, leading to a simpler and more robust approach&lt;/li&gt;
&lt;li&gt;this lead to &lt;a href=&#34;https://github.com/facile-it/paraunit/pull/93/commits/b5463b122e87f14dbaf6fa2ff78ba53f14ae737a#diff-59b76fc4702a8549daa568e542d71498R42&#34;&gt;additional tests too&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;it made me discover a &lt;a href=&#34;https://github.com/facile-it/paraunit/pull/93/commits/61c786c6faa0020465abd8243ee1415883193a94#diff-4fd831bf7fb1767a7a49e0954a98fb05R98&#34;&gt;specific behavior of the SPL file iterator classes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;strict-types-enforcing&#34;&gt;Strict types enforcing&lt;/h3&gt;

&lt;p&gt;In the last part of this PR, I also added the &lt;code&gt;declare(strict_types=1)&lt;/code&gt; directive everywhere in my code. This directive changes the behavior of type hints: with it, passed values are no longer silently casted (if possible) to the type-hinted, required type, but instead they &lt;strong&gt;trigger an immediate error if the type doesn&amp;rsquo;t match&lt;/strong&gt;; for example, passing a &lt;code&gt;&amp;quot;10&amp;quot;&lt;/code&gt; string into a &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;float&lt;/code&gt; type hint will no longer trigger an automatic conversion to &lt;code&gt;10&lt;/code&gt; or &lt;code&gt;10.0&lt;/code&gt;, but trigger an error.&lt;/p&gt;

&lt;p&gt;I would admit that this is a matter of personal preference, and I would not suggest to use this everywhere, especially if there isn&amp;rsquo;t a very thorough test coverage; it may lead to unneeded failures in very unsuspecting places, and it may cause friction when intergrating code with external libraries that take advantage of the implicit type casting that PHP has always done.&lt;/p&gt;

&lt;p&gt;But even in this little use case, &lt;a href=&#34;https://travis-ci.org/facile-it/paraunit/jobs/236293288&#34;&gt;it lead to discover a small issue&lt;/a&gt; with an outdated test code, were I was &lt;strong&gt;passing an empty string instead of a boolean&lt;/strong&gt;: that happened because I refactored a constructor some time ago, and I forgot to update the tests, and I missed it since the &lt;strong&gt;tests were not failing&lt;/strong&gt;. The error was even well highlighted by my IDE now, but before it was casted silently to a bool, and it matched the expected behavior by sheer luck!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://engineering.facile.it/images/visual-debt-typehints/phpstorm-error-highlight.png&#34; alt=&#34;The error highlighted in PHPStorm&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusions&#34;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;Type hints and other new PHP language construct help writing more cohesive, rigid code, that may lead to some &amp;ldquo;pain&amp;rdquo; while writing code and (mostly) tests; but this effort is just &lt;strong&gt;paying in advance&lt;/strong&gt;: a lot of bugs get discovered earlier, and refactoring and changing code become easier, since pieces of code that doesn&amp;rsquo;t match anymore are more visible.&lt;/p&gt;

&lt;p&gt;In the example PR, the amount of changed code that is not method signatures is trivial, but I drastically reduced the amount of possible deviations that my code could take if a wrong value is passed through it, and I fixed and tested a few additional cases that I was forgetting about. Also, the usage of the &lt;code&gt;declare(strict_types=1)&lt;/code&gt; enforces even further this approach, raising the confidence that I have in the codebase.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Swift testing avanzato: stubbing e test asincroni</title>
      <link>https://engineering.facile.it/blog/ita/swift-testing-avanzato-stubbing-e-test-asincroni/</link>
      <pubDate>Fri, 05 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>https://engineering.facile.it/blog/ita/swift-testing-avanzato-stubbing-e-test-asincroni/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://engineering.facile.it/xcode-testing-in-pratica/&#34;&gt;In un precedente articolo&lt;/a&gt; abbiamo visto le impostazioni di base in Xcode per la scrittura dei &lt;strong&gt;test unitari&lt;/strong&gt;: abbiamo evidenziato inoltre &lt;strong&gt;l&amp;rsquo;importanza e l&amp;rsquo;utilit√† intrinseca dei test&lt;/strong&gt;, attraverso un semplice esempio riguardante un caso d&amp;rsquo;uso tipico. Nel presente articolo vedremo alcune tecniche un po&amp;rsquo; pi√π avanzate:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;implementeremo uno &lt;strong&gt;Stub Object&lt;/strong&gt; in Swift;&lt;/li&gt;
&lt;li&gt;analizzeremo un altro caso di test &lt;em&gt;asincrono&lt;/em&gt;;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;lo-stub-object&#34;&gt;Lo &lt;em&gt;Stub Object&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;Uno &lt;em&gt;Stub Object&lt;/em&gt; (per il resto dell&amp;rsquo;articolo, &lt;em&gt;stub&lt;/em&gt;) rappresenta un&amp;rsquo;istanza di una certa classe, la quale &lt;em&gt;mima&lt;/em&gt; una vera classe presente nella nostra &lt;em&gt;code base&lt;/em&gt;:  l&amp;rsquo;istanza si comporta esattamente come una equivalente istanza della classe mimata, tranne alcune differenze, ad esempio &lt;strong&gt;alcuni metodi possono essere sovrascritti&lt;/strong&gt; per poter fornire &lt;strong&gt;un determinato output&lt;/strong&gt; utile per i test. Nell&amp;rsquo;implementare uno &lt;em&gt;stub&lt;/em&gt; non √® generalmente consentito modificare dettagli di logica interni relativi alla classe che stiamo mimando, ma &lt;strong&gt;√® possibile sovrascrivere metodi pubblici&lt;/strong&gt;, in modo che essi ritornino i valori che vogliamo, oppure che svolgano una particolare procedura necessaria per i test. Tanto per fare un esempio pratico potremmo &lt;em&gt;stubbare&lt;/em&gt; una classe che ci fornisce la data precisa in un certo istante, in modo da ottenere una data diversa da usare nei test, oppure un client che chiede a un server delle informazioni su un utente, in modo da far ritonare al client &lt;em&gt;stub&lt;/em&gt; delle informazioni arbitrarie.&lt;/p&gt;

&lt;p&gt;Gli &lt;em&gt;stub&lt;/em&gt; fanno parte di una classe di strumenti che sono usati nell&amp;rsquo;ambito dello &lt;em&gt;Unit Testing&lt;/em&gt; per verificare che determinati oggetti rispettino precisi &lt;strong&gt;contratti&lt;/strong&gt; stipulati tra essi: il classico articolo di Martin Fowler &lt;a href=&#34;http://martinfowler.com/articles/mocksArentStubs.html&#34;&gt;Mocks Aren&amp;rsquo;t Stubs&lt;/a&gt; √® solitamente considerato un buon punto di riferimento per comprendere i possibili strumenti usati a tal scopo. L&amp;rsquo;idea √® che, dal punto di vista dei nostri test unitari, un oggetto risulter√† essere &lt;em&gt;correttamente implementato&lt;/em&gt; se avr√† rispettato la sua parte del &lt;em&gt;contratto&lt;/em&gt; stipulato con altri oggetti, con la seguente conseguenza:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;se l&amp;rsquo;oggetto A √® correttamente implementato e l&amp;rsquo;oggetto B rispetta il contratto stipulato con l&amp;rsquo;oggetto A, allora anche l&amp;rsquo;oggetto B √® correttamente implementato&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Gli &lt;em&gt;stub&lt;/em&gt; permettono di &lt;strong&gt;disaccoppiare le logiche di funzionamento degli oggetti&lt;/strong&gt; perch√©, se abbiamo verificato il corretto funzionamento dell&amp;rsquo;oggetto A (attraverso appropriati test unitari), possiamo usare uno &lt;em&gt;stub&lt;/em&gt; di tale oggetto per verificare il corretto funzionamento dell&amp;rsquo;oggetto B nei suoi confronti, eliminando qualsiasi dipendenza di B nei confronti della logica interna dell&amp;rsquo;oggetto A. L&amp;rsquo;obiettivo √® scrivere quindi dei &lt;strong&gt;test veramente unitari&lt;/strong&gt; per l&amp;rsquo;oggetto B, anche se questo dipende dall&amp;rsquo;oggetto A. Il classico talk &lt;a href=&#34;https://vimeo.com/80533536&#34;&gt;Integration Tests are a scam&lt;/a&gt; di J.B. Rainsberger fornisce un punto di vista particolarmente &amp;ldquo;radicale&amp;rdquo; sull&amp;rsquo;argomento.&lt;/p&gt;

&lt;p&gt;Il classico caso in cui uno &lt;em&gt;stub&lt;/em&gt; risulta utile √® quello del client che fa una richiesta al server: se la logica di implementazione del server √® sotto il nostro controllo possiamo &lt;strong&gt;testare che il server rispetti il contratto con i suoi client&lt;/strong&gt; generando degli &lt;em&gt;stub&lt;/em&gt; di questi per ogni possibile richiesta; d&amp;rsquo;altra parte, per verificare che i client siano in grado di &lt;strong&gt;gestire correttamente ogni possibile risposta del server&lt;/strong&gt;, possiamo generare uno &lt;em&gt;stub&lt;/em&gt; del server che fornisca ogni possibile risposta: in questo modo possiamo testare in maniera disaccoppiata client e server.&lt;/p&gt;

&lt;h2 id=&#34;un-caso-d-uso-location-services&#34;&gt;Un caso d&amp;rsquo;uso: &lt;em&gt;Location Services&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;Il caso d&amp;rsquo;uso che tratteremo √® relativo ai &lt;strong&gt;servizi di localizzazione&lt;/strong&gt;, uno strumento frequentemente utilizzato dagli sviluppatori iOS e in generale da chi sviluppa su &lt;strong&gt;smartphone&lt;/strong&gt;: per tali sviluppatori, quello dei servizi di localizzazione √® un tema molto importante, &lt;strong&gt;fonte di complessit√† e sfide&lt;/strong&gt; che caratterizzano tipicamente il mondo &lt;em&gt;mobile&lt;/em&gt;. Non √® infatti possibile ottenere l&amp;rsquo;attuale posizione GPS in un preciso momento: l&amp;rsquo;ultima posizione GPS disponibile si basa su una regressione, effettuata dal sistema, dei dati ricevuti da diversi sensori - antenne wifi, cellulare e ovviamente GPS, e spesso anche i sensori di movimento - in diversi momenti; &lt;strong&gt;il sistema pu√≤ inviare notifiche alla nostra app in qualsiasi momento&lt;/strong&gt;, ed essa deve essere in grado di &amp;ldquo;digerire&amp;rdquo; correttamente i dati ricevuti, interpretando anche eventuali errori. Scrivere dei test unitari per verificare che la nostra app geolocalizzata funzioni correttamente pu√≤ presentare non poche difficolt√†: non possiamo infatti affidarci ai &amp;ldquo;veri&amp;rdquo; sensori del dispositivo, perch√© probabilmente i test verranno eseguiti sul simulatore, oppure magari su un vero iPhone la cui ricezione GPS in un certo istante potr√† essere pi√π o meno buona, ma essa rappresenter√† un solo caso possibile rispetto a tanti. Vogliamo essere in grado di &lt;strong&gt;testare ogni possibile risposta&lt;/strong&gt; del sistema GPS del dispositivo, dall&amp;rsquo;assenza totale di segnale al cambiamento frequente di posizione, alla &lt;strong&gt;mancata autorizzazione&lt;/strong&gt; da parte dell&amp;rsquo;utente per l&amp;rsquo;accesso ai servizi di localizzazione.&lt;/p&gt;

&lt;p&gt;Supponiamo ad esempio che una certa classe, diciamo un &lt;code&gt;UIViewController&lt;/code&gt;, esegua delle &lt;strong&gt;azioni che dipendono dalla posizione ricevuta&lt;/strong&gt;. L&amp;rsquo;idea √® quella di testare che il nostro &lt;code&gt;UIViewController&lt;/code&gt; si comporti &amp;ldquo;bene&amp;rdquo; rispetto alle notifiche del sistema di localizzazione. Il progetto Xcode contenente il codice mostrato in questo articolo √® disponibile su &lt;a href=&#34;https://github.com/broomburgo/AsyncTestingStubbing&#34;&gt;GitHub&lt;/a&gt;: si consiglia di scaricare il progetto e tenerlo a riferimento per il resto dell&amp;rsquo;articolo.&lt;/p&gt;

&lt;p&gt;Invece di usare direttamente &lt;code&gt;CLLocationManager&lt;/code&gt; per ottenere la posizione GPS del dispositivo, implementeremo una semplice classe che funger√† da &lt;em&gt;wrapper&lt;/em&gt;, chiamata &lt;code&gt;LocationCoordinator&lt;/code&gt;: un&amp;rsquo;istanza di tale classe potr√† essere configurata con due semplici funzioni &lt;code&gt;onUpdate&lt;/code&gt; e &lt;code&gt;onFailure&lt;/code&gt;, in modo da evitare l&amp;rsquo;implementazione dei vari metodi di callback del &lt;code&gt;protocol&lt;/code&gt; &lt;code&gt;CLLocationManagerDelegate&lt;/code&gt;. L&amp;rsquo;idea √® quella di passare un&amp;rsquo;istanza di &lt;code&gt;LocationCoordinator&lt;/code&gt; al nostro &lt;code&gt;UIViewController&lt;/code&gt;: quest&amp;rsquo;ultimo quindi imposter√† le due funzioni di callback indicate sopra, in modo da modificare il suo stato e i dati mostrati all&amp;rsquo;utente.&lt;/p&gt;

&lt;p&gt;Di seguito √® riportato il codice della classe &lt;code&gt;LocationCoordinator&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Foundation
import CoreLocation

public class LocationCoordinator: NSObject {
    
    public let locationManager: CLLocationManager
    
    public override init() {
        locationManager = CLLocationManager()
        super.init()
        locationManager.delegate = self
        locationManager.requestWhenInUseAuthorization()
    }
    
    private var updated: (CLLocation -&amp;gt; ())?
    public func onUpdate(value: CLLocation -&amp;gt; ()) {
        updated = value
    }
    
    private var failed: (NSError -&amp;gt; ())?
    public func onFailure(value: NSError -&amp;gt; ()) {
        failed = value
    }
}

extension LocationCoordinator: CLLocationManagerDelegate {
    
    public func locationManager(manager: CLLocationManager!, didUpdateLocations locations: [AnyObject]!) {
        let location = locations.last as! CLLocation
        if let updated = self.updated {
            updated(location)
        }
    }
    
    public func locationManager(manager: CLLocationManager!, didFailWithError error: NSError!) {
        if let failed = self.failed {
            failed(error)
        }
    }
    
    public func locationManager(manager: CLLocationManager!, didChangeAuthorizationStatus status: CLAuthorizationStatus) {
        switch status {
        case .AuthorizedWhenInUse:
            locationManager.startUpdatingLocation()
        default:
            break
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Come si pu√≤ vedere, la classe √® configurata per richiedere l&amp;rsquo;autorizzazione a leggere la posizione GPS del dispositivo quando l&amp;rsquo;app √® in uso, ma non sar√† necessario fornire questa autorizzazione per i test: creeremo infatti uno &lt;em&gt;stub&lt;/em&gt; che generer√† posizioni arbitrarie, senza usare i sensori di sistema. Si ricorda inoltre che usando iOS SDK &amp;gt;= 8.0, per usare i servizi di localizzazione sar√† necessario inserire nel file Info.plist una chiave che descrive il motivo per il quale l&amp;rsquo;app chiede l&amp;rsquo;autorizzazione ad accedere a tali servizi:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://engineering.facile.it/images/swift-testing-avanzato-stubbing-e-test-asincroni/locationUsageDescription.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Sebbene l&amp;rsquo;aggiunta della chiave &lt;code&gt;NSLocationWhenIsUseUsageDescription&lt;/code&gt; non sia necessaria per eseguire i test, senza questa chiave l&amp;rsquo;app non potr√† funzionare in iOS8 nel caso in cui provassimo ad avviarla normalmente.&lt;/p&gt;

&lt;p&gt;La classe di cui vogliamo testare il corretto funzionamento √® indicata nel progetto con il nome di &lt;code&gt;LocationViewController&lt;/code&gt;, e il suo scopo √® mostrare le attuali coordinate GPS dell&amp;rsquo;utente o mostrare un messaggio in caso di errore: un sua istanza √®, in ogni instante, caratterizzata da un &lt;code&gt;LocationState&lt;/code&gt; che rappresenta in quale stato essa si trova rispetto alla ricerca della posizione GPS:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public enum LocationState {
    case Searching
    case Found
    case Error(CLError)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;implementiamo-i-test&#34;&gt;Implementiamo i test&lt;/h2&gt;

&lt;p&gt;Per testare la classe verificheremo che, a seconda dei diversi possibili risultati ottenibili dalla ricerca della posizione GPS, un&amp;rsquo;istanza di essa &lt;strong&gt;aggiorni correttamente il suo stato attuale&lt;/strong&gt;. √à quindi necessario fare in modo che un&amp;rsquo;istanza del &lt;code&gt;LocationCoordinator&lt;/code&gt; ignori le notifiche ricevute da &lt;code&gt;CLLocationManager&lt;/code&gt;, in modo da forzare posizioni ed errori comodi per i nostri test; per farlo dichiariamo una sottoclasse di &lt;code&gt;LocationCoordinator&lt;/code&gt; chiamata &lt;code&gt;STUB_LocationCoordinator&lt;/code&gt; che modifichi la &lt;em&gt;parent class&lt;/em&gt; nel seguente modo:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ignora le notifiche del &lt;code&gt;locationManager&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;locationManager.stopUpdatingLocation()
locationManager.delegate = nil
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;dichiara 4 funzioni per forzare posizione GPS e/o errori:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;forceLocation
forceError
forceRandomDelayedLocations
forceDelayedErrorLocationUnknown
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ciascuna di queste funzioni genera le stesse notifiche che normalmente genererebbe &lt;code&gt;CLLocationManager&lt;/code&gt;. Le prime due funzioni, &lt;code&gt;forceLocation&lt;/code&gt; e &lt;code&gt;forceError&lt;/code&gt; forzano immediatamente una certa posizione GPS o un certo errore, mentre la funzione &lt;code&gt;forceRandomDelayedLocations&lt;/code&gt; genera una serie di posizioni casuali dopo un certo ritardo e a intervalli regolari, e la funzione &lt;code&gt;forceDelayedErrorLocationUnknown&lt;/code&gt; forza un errore del tipo &lt;code&gt;.LocationUnknown&lt;/code&gt; dopo un certo ritardo.&lt;/p&gt;

&lt;p&gt;Prima di procedere con i test osserviamo che nel file &lt;code&gt;AsyncTestingStubbingTests.swift&lt;/code&gt; c&amp;rsquo;√® una sezione &lt;em&gt;utility&lt;/em&gt; nella quale sono implementate alcune funzioni comode per &lt;strong&gt;rendere  il codice dei test pi√π espressivo&lt;/strong&gt;. Ad esempio la funzione &lt;code&gt;mainViewController&lt;/code&gt; ritorna l&amp;rsquo;istanza del LocationViewController utilizzata nell&amp;rsquo;interfaccia grafica nell&amp;rsquo;app. Il &lt;em&gt;testing framework&lt;/em&gt; integrato in Xcode √® chiamato &lt;code&gt;XCTest&lt;/code&gt;, e per quanto adeguatamente completo nelle sue funzionalit√†, esso √® principalmente basato su funzioni del tipo &lt;code&gt;XCTAssert&lt;/code&gt; che verificano che una qualche condizione sia vera, e se non lo √® stampano in console un messaggio di errore passato alla stessa funzione &lt;code&gt;XCTAssert&lt;/code&gt; nel momento in cui essa √® chiamata: questo pu√≤ portare alla scrittura di &lt;strong&gt;test verbosi e poco espressivi&lt;/strong&gt;. Ci sono diverse librerie facilmente integrabili nei progetti Xcode che semplificano la scrittura dei nostri &lt;em&gt;assert&lt;/em&gt;, come ad esempio &lt;a href=&#34;https://github.com/Quick/Nimble&#34;&gt;Nimble&lt;/a&gt;, ma come si pu√≤ vedere dalle poche funzioni di utility implementate nel progetto associato a questo articolo, basta poco per migliorare consistentemente la leggibilit√† dei nostri test.&lt;/p&gt;

&lt;p&gt;A questo punto possiamo procedere all&amp;rsquo;implementazione dei test. Le funzioni &lt;code&gt;testLocation&lt;/code&gt; e &lt;code&gt;testError&lt;/code&gt; testano semplicemente che lo stato del &lt;code&gt;mainViewController&lt;/code&gt; sia corretto prima e dopo la generazione di una posizione GPS e di un errore arbitrari. Tuttavia questi test non permettono di rappresentare correttamente un caso d&amp;rsquo;uso tipico, perch√© &lt;strong&gt;le notifiche sulla posizione GPS posso arrivare in qualsiasi momento&lt;/strong&gt;, e il &lt;code&gt;LocationViewController&lt;/code&gt; deve essere in grado di &lt;em&gt;reagire&lt;/em&gt; alle notifiche nel momento in cui queste si presentano. Per simulare la cosa useremo due test &lt;em&gt;asincroni&lt;/em&gt;, cio√® test il cui risultato non √® ottenuto immediatamente, ma dopo un certo tempo: l&amp;rsquo;idea √® quella di &amp;ldquo;mettere in pausa&amp;rdquo; i test per un certo numero di secondi, finch√© non si verifica una certa condizione oppure non scade il tempo: in quest&amp;rsquo;ultimo caso il test verr√† considerato &lt;strong&gt;fallito&lt;/strong&gt; da &lt;code&gt;XCTest&lt;/code&gt; perch√© la condizione attesa non si √® verificata entro il tempo richiesto.&lt;/p&gt;

&lt;p&gt;Riportiamo ad esempio il codice della funzione &lt;code&gt;testDelayedLocation&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func testDelayedLocation() {
        if let vc = mainViewController() {
            let locationExpectation = expectationWithDescription(&amp;quot;locationExpectation&amp;quot;)
            let coordinator = STUB_LocationCoordinator()
            vc.showLocationWithCoordinator(coordinator)
            vc.locationState.assertState(.Searching)
            coordinator.forceRandomDelayedLocations(0.25, times:3)
            after(0.5) {
                vc.locationState.assertState(.Found)
                after(0.25) {
                    vc.locationState.assertState(.Found)
                    locationExpectation.fulfill()
                }
            }
            vc.locationState.assertState(.Searching)
            waitForExpectationsWithTimeout(1, handler: nil)
        }
        else {
            fail(&amp;quot;this will never happen&amp;quot;)
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La funzione di utility &lt;code&gt;after&lt;/code&gt; semplicemente esegue del codice dopo un certo numero di secondi: in base all&amp;rsquo;implementazione di &lt;code&gt;forceRandomDelayedLocations&lt;/code&gt; presente in &lt;code&gt;STUB_LocationCoordinator&lt;/code&gt;, il &lt;code&gt;LocationViewController&lt;/code&gt; dovrebbe  ricevere alcune posizioni GPS a intervalli regolari dopo un certo ritardo, e per verificarlo inseriamo due &lt;em&gt;assert&lt;/em&gt;, dopo mezzo secondo e poi ancora un quarto di secondo. Per realizzare il test asincrono  definiamo una &lt;code&gt;XCTestExpectation&lt;/code&gt;, quindi una &amp;ldquo;aspettativa&amp;rdquo;, chiamata &lt;code&gt;locationExpectation&lt;/code&gt;: in coda al codice di test chiamiamo la funzione &lt;code&gt;waitForExpectationsWithTimeout&lt;/code&gt; che fa continuare la funzione di test - senza che essa &lt;em&gt;ritorni&lt;/em&gt; - fino alla &amp;ldquo;realizzazione&amp;rdquo; delle aspettative, tenendo conto di un certo tempo di timeout. Quindi, per &amp;ldquo;realizzare&amp;rdquo; un&amp;rsquo;aspettativa, chiamiamo la funzione &lt;code&gt;fulfill&lt;/code&gt; su &lt;code&gt;locationExpectation&lt;/code&gt;, ma solo dopo aver verificato che lo stato del &lt;code&gt;LocationViewController&lt;/code&gt; sia quello corretto.&lt;/p&gt;

&lt;p&gt;Possiamo estendere ulteriormente la &lt;em&gt;test suite&lt;/em&gt; implementando altri test che simulano ogni tipo di errore possibile, oppure che simulano una situazione in cui posizioni GPS e errori si alternano: una volta compresa la struttura di base per realizzare &lt;em&gt;stub&lt;/em&gt; e test asincroni sar√† facile migliorare la &lt;a href=&#34;http://engineering.facile.it/software-testing-coverage-vs-efficacia/&#34;&gt;coverage&lt;/a&gt; dei nostri test.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Xcode Testing in pratica</title>
      <link>https://engineering.facile.it/blog/ita/xcode-testing-in-pratica/</link>
      <pubDate>Thu, 09 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://engineering.facile.it/blog/ita/xcode-testing-in-pratica/</guid>
      <description>

&lt;p&gt;Tra i molti strumenti utili presenti in Xcode, il testing framework &lt;strong&gt;XCTest&lt;/strong&gt; √® certamente uno dei pi√π rilevanti, non solo per l&amp;rsquo;importanza intrinseca dello Unit Testing in generale, ma soprattutto per la facilit√† con la quale √® possibile scrivere ed eseguire test direttamente dall&amp;rsquo;IDE &lt;em&gt;out-of-the-box&lt;/em&gt;, &lt;strong&gt;senza la necessit√† di installare componenti di terze parti&lt;/strong&gt; o impostare una particolare configurazione per i progetti.&lt;/p&gt;

&lt;p&gt;In effetti Xcode, al momento della creazione di un nuovo progetto, oltre a creare un target per il binario principale crea automaticamente anche un &lt;strong&gt;target di test&lt;/strong&gt;, cio√® un bundle aggiuntivo che pu√≤ essere caricato nel bundle principale per poter fisicamente eseguire i test una volta avviata l&amp;rsquo;app. Nell&amp;rsquo;immagine seguente √® possibile vedere come, in un progetto appena creato, sia gi√† presente il test bundle, in questo caso chiamato &lt;em&gt;AwesomeAppTests.xctest&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://engineering.facile.it/images/xcode-testing-in-pratica/image_1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Come mostrato nell&amp;rsquo;immagine, Xcode ha anche creato automaticamente il file &lt;em&gt;AwesomeAppTests.swift&lt;/em&gt;, all&amp;rsquo;interno del quale potremo iniziare a scrivere i nostri test.&lt;/p&gt;

&lt;h2 id=&#34;setup-dell-ambiente-di-test&#34;&gt;Setup dell&amp;rsquo;ambiente di test&lt;/h2&gt;

&lt;p&gt;Al di l√† del meccanismo con il quale il testing avviene, √® importante capire che il codice con il quale i test sono stati scritti √® compilato in un bundle diverso, e per far s√¨ che i test &amp;ldquo;vedano&amp;rdquo; il resto dell&amp;rsquo;app, √® necessario seguire le &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AccessControl.html&#34;&gt;regole di access control tra i moduli in Swift&lt;/a&gt;; quindi classi, struct, funzioni, costanti e cos√¨ via che abbiamo dichiarato e implementato nella nostra app, o libreria che sia, &lt;strong&gt;dovranno essere marcati con la keyword *public&lt;/strong&gt;*:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public func sumOfInts (x: Int, y: Int) -&amp;gt; Int {
    return x + y
}
    
public class AwesomeItem {
    var name: String? = nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In questo modo, qualsiasi modulo esterno che importer√† il modulo costituito dalla nostra app potr√† vedere la firma della funzione &lt;code&gt;sumOfInts&lt;/code&gt; e della classe &lt;code&gt;AwesomeItem&lt;/code&gt;. Per importare nei file di testing nel modulo dell&amp;rsquo;app sar√† sufficiente scrivere &lt;code&gt;import AwesomeApp&lt;/code&gt; all&amp;rsquo;inizio del file. Aggiungiamo al progetto un file .swift, inserendo il codice appena visto: useremo questo file per scrivere tutto il codice da testare.&lt;/p&gt;

&lt;p&gt;Apriamo quindi il file &lt;em&gt;AwesomeAppTests.swift&lt;/em&gt;, importiamo il modulo &lt;code&gt;AwesomeApp&lt;/code&gt;, eliminiamo le due funzioni di test di esempio, che hanno il solo scopo di presentare la sintassi di base dei test all&amp;rsquo;utente, e scriviamo un test banale per la funzione &lt;code&gt;sumOfInts&lt;/code&gt;; avremo quindi qualcosa del genere:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class AwesomeAppTests: XCTestCase {
    
    override func setUp() {
        super.setUp()
        // Put setup code here. This method is called before the invocation of each test method in the class.
    }
    
    override func tearDown() {
        // Put teardown code here. This method is called after the invocation of each test method in the class.
        super.tearDown()
    }
    
    func testSumOfInts() {
        /// test the sumOfIntsFunction
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Xcode ha identificato la funzione &lt;code&gt;testSumOfInts&lt;/code&gt; come &lt;strong&gt;una funzione di test&lt;/strong&gt; perch√© il suo nome inizia con &amp;ldquo;test&amp;rdquo;, e ha posizionato un pulsante di avvio test proprio di fianco alla sua dichiarazione:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://engineering.facile.it/images/xcode-testing-in-pratica/image_2.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Per far eseguire a Xcode questo test, e solo questo, sar√† sufficiente cliccare su quel pulsante. In alternativa sar√† possibile selezione &amp;ldquo;Test&amp;rdquo; dal menu &amp;ldquo;Product&amp;rdquo; per far eseguire a Xcode tutti i test che l&amp;rsquo;IDE ha riconosciuto. Xcode offre anche un &lt;strong&gt;Test Navigator&lt;/strong&gt;, che mostra il nome di tutti i test implementati, raggruppati per &lt;em&gt;Test Case&lt;/em&gt;: spostando il puntatore del mouse su un test apparir√† un pulsante a forma di freccia che permetter√† di avviare singolarmente i test, oppure tutti i test relativi a un particolare &lt;em&gt;Test Case&lt;/em&gt;, o anche tutti i test scritti.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://engineering.facile.it/images/xcode-testing-in-pratica/image_3.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Per poter eseguire i test, Xcode deve effettivamente avviare l&amp;rsquo;app: selezioniamo uno dei simulatori disponibili in modo che a ogni avvio di test Xcode apra automaticamente il simulatore scelto.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://engineering.facile.it/images/xcode-testing-in-pratica/image_4.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;xctestcase-e-xctassert&#34;&gt;XCTestCase e XCTAssert&lt;/h2&gt;

&lt;p&gt;Nel framework &lt;strong&gt;XCTest&lt;/strong&gt; un &lt;em&gt;Test Case&lt;/em&gt; √® rappresentato da una sottoclasse della classe &lt;code&gt;XCTestCase&lt;/code&gt;: al momento dell&amp;rsquo;avvio dei test viene automaticamente generata un&amp;rsquo;istanza di ciascun Test Case che abbiamo implementato, e vengono eseguiti uno a uno tutti i test dichiarati, avviando le funzioni &lt;code&gt;testSomething()&lt;/code&gt; che li implementano. Anche i metodi &lt;code&gt;setUp()&lt;/code&gt; e &lt;code&gt;tearDown()&lt;/code&gt; sono chiamati automaticamente nel corso dei test: come indicano i commenti inseriti da Xcode, il metodo &lt;code&gt;setUp()&lt;/code&gt; √® chiamato immediatamente prima di ogni test, e permette di inizializzare eventuali attributi d&amp;rsquo;istanza, o variabili globali; come √® intuibile, il metodo &lt;code&gt;tearDown()&lt;/code&gt; permette di ripristinare eventualmente lo stato iniziale dopo ciascun test. L&amp;rsquo;implementazione di questi due metodi √® comunque del tutto opzionale: essi rappresentano semplicemente degli strumenti in pi√π.&lt;/p&gt;

&lt;p&gt;Poich√© &lt;strong&gt;i nostri Test Case sono effettivamente delle classi&lt;/strong&gt;, possiamo implementare anche altri metodi e attributi per ciascuna classe, che possono facilmente essere richiamati nei singoli test, come nel seguente esempio:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class AwesomeAppTests: XCTestCase {
    
		var firstInt = 0
		var secondInt = 0
		var expectedSum = 0

    override func setUp() {
        super.setUp()
        
				self.firstInt = 1
				self.secondInt = 2
				self.expectedSum = 3
    }
    
    override func tearDown() {
        self.firstInt = 0
				self.secondInt = 0
				self.expectedSum = 0
        super.tearDown()
    }
   	
    func testSumOfInts() {
				let sum = sumOfInts(self.firstInt, self.secondInt)
        XCTAssert(sum == self.expectedSum)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Come si vede dall&amp;rsquo;esempio, per testare la funzione &lt;code&gt;sumOfInts&lt;/code&gt; si √® impiegata la funzione &lt;code&gt;XCTAssert&lt;/code&gt;: tale funzione rappresenta il blocco costruttivo di base per poter scrivere i nostri unit test, e prende in ingresso da 1 a 4 parametri: il primo parametro, l&amp;rsquo;unico obbligatorio, deve essere un&amp;rsquo;espressione la cui valutazione restituisce un valore Booleano true/false, mentre gli altri parametri, del tutto opzionali poich√© caratterizzati da valori di default, rappresentano rispettivamente:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;un messaggio testuale che verr√† mostrato in console nel caso in cui il test fallisca;&lt;/li&gt;
&lt;li&gt;il file all&amp;rsquo;interno del quale √® presente il test fallito;&lt;/li&gt;
&lt;li&gt;la linea di codice in corrispondenza della quale √® presente la funzione XCTAssert relativa al test fallito;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;La libreria &lt;code&gt;XCTest&lt;/code&gt; dichiara molte diverse funzioni del tipo &lt;code&gt;XCTAssert&lt;/code&gt;, &lt;strong&gt;i cui casi di utilizzo sono chiaramente dedotti dal nome delle funzioni&lt;/strong&gt;: ad esempio la funzione &lt;code&gt;XCTAssertNil&lt;/code&gt; verifica che l&amp;rsquo;argomento, cio√® il primo parametro, sia &lt;code&gt;nil&lt;/code&gt;; la funzione &lt;code&gt;XCTAssertGreaterThan&lt;/code&gt; prende due espressioni invece di una, la cui valutazione deve restituire un valore di tipo &lt;code&gt;Comparable&lt;/code&gt; - cio√® che pu√≤ essere confrontato con altri valori tramite gli operatori maggiore/minore e derivati - e verifica che il risultato della prima espressione sia maggiore del risultato della seconda.&lt;/p&gt;

&lt;p&gt;Sfruttando le altre funzioni &lt;code&gt;XCTAssert&lt;/code&gt;, possiamo estendere &lt;code&gt;testSumOfInts&lt;/code&gt; per includere altre verifiche su &lt;code&gt;sumOfInts&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func testSumOfInts() {
        
        XCTAssertEqual(sumOfInts(self.firstInt, self.secondInt), sumOfInts(self.secondInt, self.firstInt))

        let sum = sumOfInts(self.firstInt, self.secondInt)
        XCTAssert(sum == self.expectedSum)
        if self.firstInt &amp;lt; 0 &amp;amp;&amp;amp; self.secondInt &amp;lt; 0 {
            XCTAssertLessThan(sum, 0)
        }
        else {
            if self.firstInt &amp;lt; 0 {
                XCTAssertLessThan(sum, self.secondInt)
            }
            if self.secondInt &amp;lt; 0 {
                XCTAssertLessThan(sum, self.firstInt)
            }
            if self.firstInt &amp;gt;= 0 &amp;amp;&amp;amp; self.secondInt &amp;gt;= 0 {
                XCTAssertGreaterThanOrEqual(sum, 0)
                XCTAssertGreaterThanOrEqual(sum, self.firstInt)
                XCTAssertGreaterThanOrEqual(sum, self.secondInt)
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;test-asincroni&#34;&gt;Test asincroni&lt;/h2&gt;

&lt;p&gt;La libreria XCTest include alcuni strumenti per eseguire &lt;strong&gt;test su computazioni asincrone&lt;/strong&gt;, cio√® eseguite da funzioni che non ritornano immediatamente un valore ma che potrebbero chiamare una funzione di callback a un certo punto nel futuro. Per testare una funzione asincrona √® necessario:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;creare un&amp;rsquo;istanza di &lt;code&gt;XCTestExpectation&lt;/code&gt;, un oggetto che rappresenta l&amp;rsquo;&lt;strong&gt;aspettativa&lt;/strong&gt; che ad un certo punto nel futuro accada qualcosa;&lt;/li&gt;
&lt;li&gt;informare l&amp;rsquo;istanza del &lt;code&gt;XCTestCase&lt;/code&gt;, generata automaticamente all&amp;rsquo;avvio dei test, che nel corso di un certo test √® necessario che le &lt;em&gt;aspettative&lt;/em&gt; vengano &lt;em&gt;soddisfatte&lt;/em&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Per fare un esempio, aggiungiamo una semplice funzione pubblica a &lt;em&gt;AwesomeItem.swift&lt;/em&gt; che permette di scaricare un&amp;rsquo;immagine presente a un certo URL, e chiama una funzione callback restituendo appunto una &lt;code&gt;UIImage&lt;/code&gt; che rappresenti l&amp;rsquo;immagine scaricata: per semplicit√† non gestiremo gli errori, e nel caso in cui qualcosa vada storto otterremo semplicemente &lt;code&gt;nil&lt;/code&gt; al posto dell&amp;rsquo;immagine (quindi l&amp;rsquo;oggetto effettivamente ottenuto sar√† di tipo &lt;code&gt;UIImage?&lt;/code&gt;, cio√® un oggetto opzionale). Per poter manipolare &lt;code&gt;UIImage&lt;/code&gt; dobbiamo importare &lt;code&gt;UIKit&lt;/code&gt; in &lt;em&gt;AwesomeItem.swift&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Foundation
import UIKit

public func sumOfInts (a: Int, b: Int) -&amp;gt; Int {
    return a + b
}

public func downloadImage (imageURL: NSURL, callback: (UIImage?) -&amp;gt; ()) {
    let task = NSURLSession.sharedSession().downloadTaskWithRequest(NSURLRequest(URL: imageURL), completionHandler: { (tempLocalURL: NSURL!, response: NSURLResponse!, error: NSError!) -&amp;gt; Void in
        if let path = tempLocalURL?.path {
            let image = UIImage(contentsOfFile: path)
            NSFileManager.defaultManager().removeItemAtPath(path, error: nil)
            callback(image)
        }
        else {
            callback(nil)
        }
    })
}

public class AwesomeItem {
    var name: String? = nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Che si riesca a meno a scaricare l&amp;rsquo;immagine, la funzione di callback deve comunque essere chiamata in un tempo ragionevole, e l&amp;rsquo;obbiettivo del test asincrono sar√† proprio quello di verificare che la tale funzione venga chiamata, ignorando  l&amp;rsquo;oggetto ottenuto per l&amp;rsquo;immagine. Segue una possibile implementazione per questo test, nella quale creiamo una &lt;code&gt;XCTestExpectation&lt;/code&gt; e impostiamo un&amp;rsquo;attesa di 5 secondi: √® ovviamente possibile sincronizzare il tempo di attesa con il tempo di timeout della sessione di download creata, ma per semplicit√† imposteremo un tempo forfettario.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func testDownloadImageCallback() {
        
        let downloadImageCallbackExpectation = self.expectationWithDescription(&amp;quot;downloadImageCallbackExpectation&amp;quot;)
        
        let imageUrl = NSURL(string: &amp;quot;http://goo.gl/XYwppm&amp;quot;)!
        
        downloadImage(imageUrl) { image in
            downloadImageCallbackExpectation!.fulfill();
        }
        
        self.waitForExpectationsWithTimeout(5.0, handler: nil)
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Se proviamo ad avviare il test cliccando sull&amp;rsquo;icona di avvio apparsa in Xcode proprio a sinistra della riga di dichiarazione della funzione, analogamente a quando mostrato prima, vedremo che Xcode rimarr√† bloccato per 5 secondi prima di mostrare il messaggio &lt;code&gt;Asynchronous wait failed: Exceeded timeout of 5 seconds, with unfulfilled expectations: &amp;quot;downloadImageCallbackExpectation&amp;quot;.&lt;/code&gt;: come mai? Il fallimento del test ci informa subito del fatto che la funzione di download dell&amp;rsquo;immagine che abbiamo scritto ha qualche problema: √® facile vedere che esso √® dovuto al fatto che non abbiamo chiamato &lt;code&gt;resume()&lt;/code&gt; sulla task di download creata. Correggiamo quindi la nostra funzione &lt;code&gt;downloadImage&lt;/code&gt; nel seguente modo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public func downloadImage (imageURL: NSURL, callback: (UIImage?) -&amp;gt; ()) {
    let task = NSURLSession.sharedSession().downloadTaskWithRequest(NSURLRequest(URL: imageURL), completionHandler: { (tempLocalURL: NSURL!, response: NSURLResponse!, error: NSError!) -&amp;gt; Void in
        if let path = tempLocalURL?.path {
            let image = UIImage(contentsOfFile: path)
            NSFileManager.defaultManager().removeItemAtPath(path, error: nil)
            callback(image)
        }
        else {
            callback(nil)
        }
    })
    task.resume()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Il test ci ha immediatamente informati dell&amp;rsquo;errore&lt;/strong&gt;, e ci ha permesso di evitare una possibile sorgente di bug nel nostro codice, e diversi mal di testa. Grazie al modo &lt;em&gt;seamless&lt;/em&gt; nel quale il framework XCTest √® integrato in Xcode, risulta facile e veloce scrivere test che permettano di verificare immediatamente se il nostro codice funziona come dovrebbe, ed &lt;strong&gt;√® Xcode stesso a incoraggiare la scrittura di test&lt;/strong&gt; nel corso della realizzazione di un&amp;rsquo;app o di una libreria generando automaticamente un target di test ogni volta in cui si crea un nuovo progetto: non ci sono pi√π scuse quindi per non iniziare a scrivere test completi ed efficienti che permettano di &lt;strong&gt;realizzare software migliore&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Il progetto Xcode contenente tutto il codice mostrato nell&amp;rsquo;articolo √® disponibile su &lt;a href=&#34;https://github.com/broomburgo/xcode-testing-in-pratica&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Software testing: Coverage vs Efficacia</title>
      <link>https://engineering.facile.it/blog/ita/software-testing-coverage-vs-efficacia/</link>
      <pubDate>Mon, 16 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>https://engineering.facile.it/blog/ita/software-testing-coverage-vs-efficacia/</guid>
      <description>

&lt;p&gt;Controllare il tasso di coverage dei test √® un&amp;rsquo;attivit√† frequente tra gli sviluppatori.&lt;/p&gt;

&lt;p&gt;Numerosi sono i fattori che hanno reso il code coverage popolare:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;√® una metrica facile da comprendere;&lt;/li&gt;
&lt;li&gt;si misura senza difficolt√†;&lt;/li&gt;
&lt;li&gt;√® oggettiva e imparziale;&lt;/li&gt;
&lt;li&gt;√® universale (applicabile a tutti i paradigmi di programmazione).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ma al di l√† di questi vantaggi, &lt;strong&gt;&lt;em&gt;possiamo affermare che una test suite con un&amp;rsquo;alta percentuale di coverage sia realmente efficace?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;quando-un-test-√®-efficace&#34;&gt;Quando un test √® efficace?&lt;/h3&gt;

&lt;p&gt;Una test suite √® considerata efficace se consente di rilevare una grande quantit√† di failure; d&amp;rsquo;altronde, ci√≤ √® proprio la finalit√† ultima del software testing.
La massima efficacia √® realizzabile solo applicando testing esaustivo ma, siccome ci√≤ √® spesso impraticabile, ci si accontenta di test pi√π semplici con un&amp;rsquo;efficacia inferiore.
√à importante notare che, a differenza del coverage, il livello d&amp;rsquo;efficacia viene stabilito soggettivamente dallo sviluppatore.&lt;/p&gt;

&lt;h3 id=&#34;quanti-tipi-di-coverage&#34;&gt;Quanti tipi di coverage?&lt;/h3&gt;

&lt;p&gt;La copertura pu√≤ essere misurata in molti modi differenti. Essa √® sempre un rapporto tipicamente espresso in forma percentuale.&lt;/p&gt;

&lt;p&gt;La formula per il calcolo del coverage √® la seguente:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://engineering.facile.it/images/software-testing-coverage-vs-efficacia/CodeCogsEqn.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Notare il termine generico &lt;em&gt;obiettivo&lt;/em&gt;: diverse tipologie di coverage hanno obiettivi differenti.
Qui di seguito √® presente un elenco esemplificativo e non esaustivo delle diverse tipologie di coverage:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Statement coverage&lt;/li&gt;
&lt;li&gt;Branch coverage (o decision coverage)&lt;/li&gt;
&lt;li&gt;Condition coverage&lt;/li&gt;
&lt;li&gt;Function/Method coverage&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Nel corso di quest&amp;rsquo;articolo si fa riferimento sempre allo Statement coverage, talvolta chiamato semplicemente &amp;ldquo;coverage&amp;rdquo;.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;un-esempio-pratico&#34;&gt;Un esempio pratico&lt;/h3&gt;

&lt;h4 id=&#34;funzione-under-test&#34;&gt;Funzione under-test&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def weightedAverage(array):
	sum = weightSum = 0     # Bug, dovrebbe essere: sum = weightSum = 0.0
	for (value, weight) in array:
		sum += value        # Bug, dovrebbe essere: sum += value * weight
		weightSum += weight
	return sum / weightSum
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Le specifiche della funzione &lt;em&gt;weightedAverage&lt;/em&gt; sono le seguenti:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Calcolare la media ponderata di un array contenente coppie di valori.&lt;br /&gt;
Ad esempio: &lt;code&gt;[(10, 2), (11, 4), (5, 1)]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Restituire sempre un risultato di tipo float.&lt;/li&gt;
&lt;li&gt;Non effettuare divisione tra interi per non ridurre la precisione del risultato.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I commenti gi√† presenti nel codice evidenziano due errori importanti:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;La media non √® calcolata correttamente: l&amp;rsquo;istruzione &lt;code&gt;sum += value&lt;/code&gt; dovrebbe essere &lt;code&gt;sum += value * weight&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;L&amp;rsquo;output della funzione non √® di tipo float se i dati di input sono interi.&lt;br /&gt;
L&amp;rsquo;errore √® risolvibile modificando &lt;code&gt;sum = weightSum = 0&lt;/code&gt; in &lt;code&gt;sum = weightSum = 0.0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;test-suite-1&#34;&gt;Test suite #1&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def testWeightedAverage():
	expected = 25.0
	inputArray = [(24, 1), (26, 1)]
	actual = weightedAverage(inputArray)
	if expected == actual:
		print &#39;Okay&#39;
	else:
		print &#39;Failure!&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La test suite #1 ha statement coverage 100%, tuttavia non consente di rilevare i due errori menzionati in precedenza. Sebbene la coverage sia alta, l&amp;rsquo;efficacia √® molto bassa.&lt;/p&gt;

&lt;h4 id=&#34;test-suite-2&#34;&gt;Test suite #2&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def testWeightedAverageDifferentWeight():
	expected = 26.0
	inputArray = [(24, 1), (27, 2)]
	actual = weightedAverage(inputArray)
	if expected == actual:
		print &#39;Okay&#39;
	else:
		print &#39;Failure!&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La test suite #2 ha statement coverage 100%, ma non consente di verificare correttamente che l&amp;rsquo;output della funzione sia di tipo float.
Il primo errore viene rilevato, il secondo no.
√à importante notare che questo problema viene risolto aggiungendo l&amp;rsquo;asserzione &lt;code&gt;type(actual) is float&lt;/code&gt;.&lt;br /&gt;
Le asserzioni sono parte fondamentale del testing; date loro la giusta importanza! Ogni buona asserzione in pi√π consente di migliorare sensibilmente l&amp;rsquo;efficacia dei vostri test case.&lt;/p&gt;

&lt;h4 id=&#34;test-suite-3&#34;&gt;Test suite #3&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def testWeightedAverageFloatResult():
	expected = 27.2
	inputArray = [(24, 1), (28, 4)]
	actual = weightedAverage(inputArray)
	if expected == actual:
		print &#39;Okay&#39;
	else:
		print &#39;Failure!&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La test suite #3 ha statement coverage 100% ed √® efficace perch√© ci consente di rilevare tutti gli errori.&lt;/p&gt;

&lt;h3 id=&#34;conclusioni&#34;&gt;Conclusioni&lt;/h3&gt;

&lt;p&gt;Abbiamo visto che percentuali di coverage alte non sempre implicano test efficaci.
Tuttavia test suite efficaci hanno necessariamente bisogno di coverage rate alti.
In temini logici possiamo quindi affermare che:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://engineering.facile.it/images/software-testing-coverage-vs-efficacia/CodeCogsEqn--1-.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Coverage rate bassi sono un campanello d&amp;rsquo;allarme che ci consente di stabilire la scarca efficacia dei test.
Possiamo infatti affermare che:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://engineering.facile.it/images/software-testing-coverage-vs-efficacia/CodeCogsEqn--2-.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>