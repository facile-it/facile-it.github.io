<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Software testing on Facile.it Engineering</title>
    <link>https://engineering.facile.it/categories/software-testing/</link>
    <description>Recent content in Software testing on Facile.it Engineering</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 12 Sep 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://engineering.facile.it/categories/software-testing/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>How to gradually upgrade toward PHPUnit 6 with namespaced classes</title>
      <link>https://engineering.facile.it/blog/eng/phpunit-upgrade-namespace/</link>
      <pubDate>Tue, 12 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://engineering.facile.it/blog/eng/phpunit-upgrade-namespace/</guid>
      <description>In the latest months I wrote multiple times, in different projects, code migrating PHPUnit toward major version 6. This upgrade is harder than the previous one, since in this version it was introduced a big breaking change: all classes got (finally!) namespaced.
This means that any usage of those classes in your project needs to be updated. It may seem a simple find &amp;amp; replace job, but since you need to introduce at least one use PHPUnit\Framework\TestCase line at the top of each one of your test classes, it&amp;rsquo;s a boring and a little more than trivial task; also, upgrading it in a single big jump may not be feasible or prudent, especially in the case of open source or distributed libraries, where backward compatibility and support for old PHP versions must be ensured.</description>
    </item>
    
    <item>
      <title>Why type hints and interfaces are not visual debt</title>
      <link>https://engineering.facile.it/blog/eng/visual-debt-typehints/</link>
      <pubDate>Wed, 31 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://engineering.facile.it/blog/eng/visual-debt-typehints/</guid>
      <description>A few days ago I stumbled on a strange tweet that was highlighting a controversy about scalar type hints.
Scalar type hints &amp;amp; return types vs no scalar type hints &amp;amp; return types is #PHP&amp;#39;s new spaces vs tabs
&amp;mdash; Cees-Jan üîä Kiewiet (@WyriHaximus) 19 maggio 2017 
After asking references about this, someone alluded to this very short video: &amp;ldquo;PHP Bits: Visual Debt&amp;rdquo; (it&amp;rsquo;s only 3 minutes, please watch it before continue reading).</description>
    </item>
    
    <item>
      <title>Swift testing avanzato: stubbing e test asincroni</title>
      <link>https://engineering.facile.it/blog/ita/swift-testing-avanzato-stubbing-e-test-asincroni/</link>
      <pubDate>Fri, 05 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>https://engineering.facile.it/blog/ita/swift-testing-avanzato-stubbing-e-test-asincroni/</guid>
      <description>In un precedente articolo abbiamo visto le impostazioni di base in Xcode per la scrittura dei test unitari: abbiamo evidenziato inoltre l&amp;rsquo;importanza e l&amp;rsquo;utilit√† intrinseca dei test, attraverso un semplice esempio riguardante un caso d&amp;rsquo;uso tipico. Nel presente articolo vedremo alcune tecniche un po&amp;rsquo; pi√π avanzate:
 implementeremo uno Stub Object in Swift; analizzeremo un altro caso di test asincrono;  Lo Stub Object Uno Stub Object (per il resto dell&amp;rsquo;articolo, stub) rappresenta un&amp;rsquo;istanza di una certa classe, la quale mima una vera classe presente nella nostra code base: l&amp;rsquo;istanza si comporta esattamente come una equivalente istanza della classe mimata, tranne alcune differenze, ad esempio alcuni metodi possono essere sovrascritti per poter fornire un determinato output utile per i test.</description>
    </item>
    
    <item>
      <title>Xcode Testing in pratica</title>
      <link>https://engineering.facile.it/blog/ita/xcode-testing-in-pratica/</link>
      <pubDate>Thu, 09 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://engineering.facile.it/blog/ita/xcode-testing-in-pratica/</guid>
      <description>Tra i molti strumenti utili presenti in Xcode, il testing framework XCTest √® certamente uno dei pi√π rilevanti, non solo per l&amp;rsquo;importanza intrinseca dello Unit Testing in generale, ma soprattutto per la facilit√† con la quale √® possibile scrivere ed eseguire test direttamente dall&amp;rsquo;IDE out-of-the-box, senza la necessit√† di installare componenti di terze parti o impostare una particolare configurazione per i progetti.
In effetti Xcode, al momento della creazione di un nuovo progetto, oltre a creare un target per il binario principale crea automaticamente anche un target di test, cio√® un bundle aggiuntivo che pu√≤ essere caricato nel bundle principale per poter fisicamente eseguire i test una volta avviata l&amp;rsquo;app.</description>
    </item>
    
    <item>
      <title>Software testing: Coverage vs Efficacia</title>
      <link>https://engineering.facile.it/blog/ita/software-testing-coverage-vs-efficacia/</link>
      <pubDate>Mon, 16 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>https://engineering.facile.it/blog/ita/software-testing-coverage-vs-efficacia/</guid>
      <description>Controllare il tasso di coverage dei test √® un&amp;rsquo;attivit√† frequente tra gli sviluppatori.
Numerosi sono i fattori che hanno reso il code coverage popolare:
 √® una metrica facile da comprendere; si misura senza difficolt√†; √® oggettiva e imparziale; √® universale (applicabile a tutti i paradigmi di programmazione).  Ma al di l√† di questi vantaggi, possiamo affermare che una test suite con un&amp;rsquo;alta percentuale di coverage sia realmente efficace?</description>
    </item>
    
  </channel>
</rss>