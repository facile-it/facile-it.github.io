<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Software Testing on Facile.it Engineering</title>
    <link>https://engineering.facile.it/categories/software-testing/</link>
    <description>Recent content in Software Testing on Facile.it Engineering</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 22 Oct 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://engineering.facile.it/categories/software-testing/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Automated testing: a step back</title>
      <link>https://engineering.facile.it/blog/eng/automated-testing-a-step-back/</link>
      <pubDate>Thu, 22 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://engineering.facile.it/blog/eng/automated-testing-a-step-back/</guid>
      <description>The goal of this article is to define basic concepts related to testing, trying not to take anything for granted.
Why do we test?? Why is it important to write automated tests? I asked myself and I did some research because the answer to this question was not obvious to me. I knew it was important but I didn&amp;rsquo;t know why. So, I decided to try to explain it starting from a point of view as impartial as possible.</description>
    </item>
    
    <item>
      <title>How to gradually upgrade toward PHPUnit 6 with namespaced classes</title>
      <link>https://engineering.facile.it/blog/eng/phpunit-upgrade-namespace/</link>
      <pubDate>Tue, 12 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://engineering.facile.it/blog/eng/phpunit-upgrade-namespace/</guid>
      <description>In the latest months I wrote multiple times, in different projects, code migrating PHPUnit toward major version 6. This upgrade is harder than the previous one, since in this version it was introduced a big breaking change: all classes got (finally!) namespaced.
This means that any usage of those classes in your project needs to be updated. It may seem a simple find &amp;amp; replace job, but since you need to introduce at least one use PHPUnit\Framework\TestCase line at the top of each one of your test classes, it&amp;rsquo;s a boring and a little more than trivial task; also, upgrading it in a single big jump may not be feasible or prudent, especially in the case of open source or distributed libraries, where backward compatibility and support for old PHP versions must be ensured.</description>
    </item>
    
    <item>
      <title>Why type hints and interfaces are not visual debt</title>
      <link>https://engineering.facile.it/blog/eng/visual-debt-typehints/</link>
      <pubDate>Wed, 31 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://engineering.facile.it/blog/eng/visual-debt-typehints/</guid>
      <description>A few days ago I stumbled on a strange tweet that was highlighting a controversy about scalar type hints.
Scalar type hints &amp;amp; return types vs no scalar type hints &amp;amp; return types is #PHP&amp;#39;s new spaces vs tabs
&amp;mdash; Cees-Jan üîä Kiewiet (@WyriHaximus) 19 maggio 2017  After asking references about this, someone alluded to this very short video: &amp;ldquo;PHP Bits: Visual Debt&amp;rdquo; (it&amp;rsquo;s only 3 minutes, please watch it before continue reading).</description>
    </item>
    
    <item>
      <title>Paraunit: test paralleli, Doctrine e le fixture</title>
      <link>https://engineering.facile.it/blog/ita/paraunit/</link>
      <pubDate>Fri, 09 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://engineering.facile.it/blog/ita/paraunit/</guid>
      <description>Questo articolo √® la sintesi di un talk presentato al SymfonyDay 2015; potete trovare le slide qui.
I test e la loro durata Sviluppare applicazioni scrivendo test e facendo Test Driven Development √® un&amp;rsquo;ottima pratica, e d√† parecchie soddisfazioni. Con l&amp;rsquo;andare del tempo, si fa crescere la suite di test del proprio progetto, cercando di aumentarne la copertura e l&amp;rsquo;efficacia e si scrivono nuovi test corrispondenti alle nuove funzionalit√† che vengono man mano sviluppate.</description>
    </item>
    
    <item>
      <title>Swift testing avanzato: stubbing e test asincroni</title>
      <link>https://engineering.facile.it/blog/ita/swift-testing-avanzato-stubbing-e-test-asincroni/</link>
      <pubDate>Fri, 05 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>https://engineering.facile.it/blog/ita/swift-testing-avanzato-stubbing-e-test-asincroni/</guid>
      <description>In un precedente articolo abbiamo visto le impostazioni di base in Xcode per la scrittura dei test unitari: abbiamo evidenziato inoltre l&amp;rsquo;importanza e l&amp;rsquo;utilit√† intrinseca dei test, attraverso un semplice esempio riguardante un caso d&amp;rsquo;uso tipico. Nel presente articolo vedremo alcune tecniche un po&amp;rsquo; pi√π avanzate:
 implementeremo uno Stub Object in Swift; analizzeremo un altro caso di test asincrono;  Lo Stub Object Uno Stub Object (per il resto dell&amp;rsquo;articolo, stub) rappresenta un&amp;rsquo;istanza di una certa classe, la quale mima una vera classe presente nella nostra code base: l&amp;rsquo;istanza si comporta esattamente come una equivalente istanza della classe mimata, tranne alcune differenze, ad esempio alcuni metodi possono essere sovrascritti per poter fornire un determinato output utile per i test.</description>
    </item>
    
    <item>
      <title>Xcode Testing in pratica</title>
      <link>https://engineering.facile.it/blog/ita/xcode-testing-in-pratica/</link>
      <pubDate>Thu, 09 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://engineering.facile.it/blog/ita/xcode-testing-in-pratica/</guid>
      <description>Tra i molti strumenti utili presenti in Xcode, il testing framework XCTest √® certamente uno dei pi√π rilevanti, non solo per l&amp;rsquo;importanza intrinseca dello Unit Testing in generale, ma soprattutto per la facilit√† con la quale √® possibile scrivere ed eseguire test direttamente dall&amp;rsquo;IDE out-of-the-box, senza la necessit√† di installare componenti di terze parti o impostare una particolare configurazione per i progetti.
In effetti Xcode, al momento della creazione di un nuovo progetto, oltre a creare un target per il binario principale crea automaticamente anche un target di test, cio√® un bundle aggiuntivo che pu√≤ essere caricato nel bundle principale per poter fisicamente eseguire i test una volta avviata l&amp;rsquo;app.</description>
    </item>
    
    <item>
      <title>Software testing: Coverage vs Efficacia</title>
      <link>https://engineering.facile.it/blog/ita/software-testing-coverage-vs-efficacia/</link>
      <pubDate>Mon, 16 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>https://engineering.facile.it/blog/ita/software-testing-coverage-vs-efficacia/</guid>
      <description>Controllare il tasso di coverage dei test √® un&amp;rsquo;attivit√† frequente tra gli sviluppatori.
Numerosi sono i fattori che hanno reso il code coverage popolare:
 √® una metrica facile da comprendere; si misura senza difficolt√†; √® oggettiva e imparziale; √® universale (applicabile a tutti i paradigmi di programmazione).  Ma al di l√† di questi vantaggi, possiamo affermare che una test suite con un&amp;rsquo;alta percentuale di coverage sia realmente efficace?</description>
    </item>
    
  </channel>
</rss>